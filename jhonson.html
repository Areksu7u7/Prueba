<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graficador de Grafos - An√°lisis de Algoritmos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background: linear-gradient(135deg, #a8d8ea, #aa96da, #c5fad5);
            color: #333;
        }
        header {
            background-color: rgba(49, 61, 82, 0.9);
            color: white;
            padding: 1rem;
            text-align: center;
            border-bottom: 3px solid #7c83fd;
        }
        .container {
            display: flex;
            flex: 1;
            max-height: calc(100vh - 80px);
        }
        .sidebar {
            width: 300px;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 1rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            border-right: 2px solid #7c83fd;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            max-height: 100%;
        }
        .canvas-container {
            flex: 1;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            position: relative;
            max-height: 70vh;
            border: 2px solid #7c83fd;
        }
        #graphCanvas {
            display: block;
            background-color: #f8f9ff;
            width: 100%;
            height: 100%;
        }
        .form-group {
            margin-bottom: 1rem;
        }
        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #4a5568;
        }
        input, select, button {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            background-color: #f7fafc;
        }
        button {
            background-color: #7c83fd;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: #6b73e6;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }
        button.delete {
            background-color: #ff6b6b;
        }
        button.delete:hover {
            background-color: #ee5d5d;
        }
        button.edit {
            background-color: #ffa34d;
        }
        button.edit:hover {
            background-color: #ee9545;
        }
        button.clear {
            background-color: #ff9a76;
            margin-top: 1rem;
        }
        button.clear:hover {
            background-color: #ee8a6d;
        }
        button.print {
            background-color: #4fd1c5;
            margin-top: 0.5rem;
        }
        button.print:hover {
            background-color: #38b2ac;
        }
        button.algorithm {
            background-color: #9b59b6;
            margin-top: 0.5rem;
        }
        button.algorithm:hover {
            background-color: #8e44ad;
        }
        .help-btn {
            background-color: #4fd1c5;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
            z-index: 100;
        }
        .help-btn:hover {
            background-color: #38b2ac;
            transform: scale(1.1);
        }
        .node {
            position: absolute;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16);
            transition: transform 0.2s;
            font-weight: bold;
            border: 2px solid #5a62d4;
        }
        .node:hover {
            transform: scale(1.08);
        }
        .node.selected {
            box-shadow: 0 0 0 3px #ffa34d, 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        .node.highlighted {
            box-shadow: 0 0 0 4px #9b59b6, 0 4px 12px rgba(155, 89, 182, 0.4);
            animation: pulse 1.5s infinite;
        }
        .node.critical {
            box-shadow: 0 0 0 4px #e74c3c, 0 4px 12px rgba(231, 76, 60, 0.4);
            animation: criticalPulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes criticalPulse {
            0% { box-shadow: 0 0 0 4px #e74c3c, 0 4px 12px rgba(231, 76, 60, 0.4); }
            50% { box-shadow: 0 0 0 6px #e74c3c, 0 6px 16px rgba(231, 76, 60, 0.6); }
            100% { box-shadow: 0 0 0 4px #e74c3c, 0 4px 12px rgba(231, 76, 60, 0.4); }
        }
        .file-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e2e8f0;
        }
        .mode-selector {
            display: flex;
            margin-bottom: 1rem;
            background-color: #edf2f7;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .mode-btn {
            flex: 1;
            padding: 0.5rem;
            text-align: center;
            background-color: #e2e8f0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mode-btn.active {
            background-color: #7c83fd;
            color: white;
        }
        .instructions {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #4fd1c5;
        }
        h2 {
            margin-bottom: 1rem;
            color: #4a5568;
            border-bottom: 2px solid #7c83fd;
            padding-bottom: 0.5rem;
        }
        h3 {
            margin: 1rem 0 0.5rem 0;
            color: #4a5568;
        }
        .context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none;
            overflow: hidden;
        }
        .context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .context-menu li {
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .context-menu li:hover {
            background-color: #ebf4ff;
        }
        .matrix-container {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #7c83fd;
            max-height: 200px;
            overflow-y: auto;
        }
        .matrix-table {
            border-collapse: collapse;
            width: 100%;
        }
        .matrix-table th, .matrix-table td {
            border: 1px solid #e2e8f0;
            padding: 4px 8px;
            text-align: center;
        }
        .matrix-table th {
            background-color: #edf2f7;
        }
        .status-bar {
            margin-top: 10px;
            padding: 8px;
            background-color: #ebf4ff;
            border-radius: 6px;
            font-size: 14px;
            border-left: 3px solid #7c83fd;
        }
        .anime-decoration {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 24px;
            opacity: 0.7;
        }
        .color-picker {
            display: flex;
            gap: 5px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .color-option:hover {
            transform: scale(1.2);
        }
        .color-option.selected {
            border: 2px solid #333;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .print-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .print-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
        }
        .print-actions {
            margin-top: 15px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .results-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .results-content {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow: auto;
            width: 600px;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .results-table th, .results-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        .results-table th {
            background-color: #f2f2f2;
        }
        .results-table tr:hover {
            background-color: #f5f5f5;
        }
        .path-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #9b59b6;
        }
        .algorithm-controls {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #9b59b6;
        }
        .critical-path {
            margin-top: 10px;
            padding: 10px;
            background-color: #ffe6e6;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
        }
    </style>
</head>
<body>
    <header>
        <h1>‚ú® Graficador de Grafos - An√°lisis de Algoritmos ‚ú®</h1>
    </header>

    <div class="container">
        <div class="sidebar">
            <h2>üéØ Gesti√≥n de Nodos</h2>
            <div class="form-group">
                <label for="nodeName">Nombre del Nodo:</label>
                <input type="text" id="nodeName" placeholder="Ingrese nombre">
            </div>
            <div class="form-group">
                <label for="nodeValue">Valor del Nodo:</label>
                <input type="text" id="nodeValue" placeholder="Ingrese valor">
            </div>
            <div class="form-group">
                <label>Color del Nodo:</label>
                <div class="color-picker" id="colorPicker">
                    <div class="color-option selected" style="background-color: #7c83fd;" data-color="#7c83fd"></div>
                    <div class="color-option" style="background-color: #ff6b6b;" data-color="#ff6b6b"></div>
                    <div class="color-option" style="background-color: #4fd1c5;" data-color="#4fd1c5"></div>
                    <div class="color-option" style="background-color: #ffa34d;" data-color="#ffa34d"></div>
                    <div class="color-option" style="background-color: #9b59b6;" data-color="#9b59b6"></div>
                    <div class="color-option" style="background-color: #48bb78;" data-color="#48bb78"></div>
                </div>
            </div>
            <button id="createNodeBtn">‚ú® Crear Nodo</button>
            <button id="editNodeBtn" class="edit">‚úèÔ∏è Editar Nodo Seleccionado</button>
            <button id="deleteNodeBtn" class="delete">üóëÔ∏è Eliminar Nodo Seleccionado</button>

            <h2>üîó Gesti√≥n de Aristas</h2>
            <div class="form-group">
                <label for="edgeType">Tipo de Arista:</label>
                <select id="edgeType">
                    <option value="directed">Dirigida</option>
                    <option value="undirected">No Dirigida</option>
                </select>
            </div>
            <div class="form-group">
                <label for="edgeWeight">Peso de la Arista:</label>
                <input type="number" id="edgeWeight" value="1" min="1">
            </div>
            <button id="createEdgeBtn">üîó Crear Arista entre Nodos Seleccionados</button>
            <button id="deleteEdgeBtn" class="delete">‚ûñ Eliminar Arista entre Nodos</button>
            <button id="editEdgeBtn" class="edit">‚úèÔ∏è Editar Arista Seleccionada</button>

            <div class="algorithm-controls">
                <h2>üìä Algoritmos</h2>
                <button id="johnsonBtn" class="algorithm">üßÆ Ejecutar Algoritmo de Johnson</button>
                <button id="showResultsBtn" class="algorithm">üìà Ver Resultados de Johnson</button>
                <button id="clearResultsBtn" class="delete">üóëÔ∏è Limpiar Resultados</button>
            </div>

            <div class="file-section">
                <h2>üíæ Gesti√≥n de Archivos</h2>
                <div class="form-group">
                    <label for="graphName">Nombre del Grafo:</label>
                    <input type="text" id="graphName" placeholder="Nombre para guardar">
                </div>
                <button id="saveGraphBtn">üíæ Guardar Grafo</button>
                <div class="form-group">
                    <label for="loadGraph">Cargar Grafo:</label>
                    <input type="file" id="loadGraph" accept=".json">
                </div>
            </div>

            <button id="clearAllBtn" class="clear">üßπ Limpiar Todo</button>

            <div class="matrix-container">
                <h3>üìä Matriz de Adyacencia</h3>
                <div id="adjacencyMatrix"></div>
                <button id="printMatrixBtn" class="print">üñ®Ô∏è Imprimir Matriz</button>
            </div>

            <div class="instructions">
                <h3>üìã Instrucciones:</h3>
                <p>1. Crear nodo: Complete los campos y haga clic en "Crear Nodo"</p>
                <p>2. Seleccionar nodo: Haga clic en un nodo para seleccionarlo</p>
                <p>3. Click derecho: Muestra opciones contextuales para nodos y aristas</p>
                <p>4. Crear arista: Seleccione dos nodos y haga clic en "Crear Arista"</p>
                <p>5. Mover nodos: Arrastre los nodos con el mouse</p>
                <p>6. Cambiar color: Seleccione un nodo y elija un color</p>
                <p>7. Johnson: Calcula caminos m√°s cortos entre todos los nodos</p>
                <p>8. Rutas cr√≠ticas: Se muestran en rojo despu√©s de ejecutar Johnson</p>
            </div>
            
            <div class="status-bar" id="statusBar">
                Modo: Seleccionar/Mover
            </div>
            <div class="anime-decoration">(>·¥ó‚Ä¢)</div>
        </div>

        <div class="main-content">
            <div class="mode-selector">
                <div class="mode-btn active" id="selectMode">üîç Seleccionar/Mover</div>
                <div class="mode-btn" id="createMode">‚ú® Crear Nodos</div>
                <div class="mode-btn" id="connectMode">üîó Conectar Nodos</div>
            </div>
            <div class="canvas-container">
                <canvas id="graphCanvas"></canvas>
            </div>
        </div>
    </div>

    <div id="contextMenu" class="context-menu">
        <ul>
            <li id="ctxEditNode">‚úèÔ∏è Editar nodo</li>
            <li id="ctxDeleteNode">üóëÔ∏è Eliminar nodo</li>
            <li id="ctxCreateEdge">üîó Crear arista desde aqu√≠</li>
            <li id="ctxChangeColor">üé® Cambiar color</li>
        </ul>
    </div>

    <div id="contextMenuEdge" class="context-menu">
        <ul>
            <li id="ctxDeleteEdge">‚ûñ Eliminar arista</li>
            <li id="ctxEditEdge">‚úèÔ∏è Editar peso</li>
        </ul>
    </div>

    <div id="printModal" class="print-modal">
        <div class="print-content">
            <h2>Matriz de Adyacencia</h2>
            <div id="printMatrixContent"></div>
            <div class="print-actions">
                <button id="printCloseBtn">Cerrar</button>
                <button id="printActualBtn">Imprimir</button>
            </div>
        </div>
    </div>
    
    <div id="resultsModal" class="results-modal">
        <div class="results-content">
            <h2>Resultados del Algoritmo de Johnson</h2>
            <div id="resultsInfo"></div>
            <div class="print-actions">
                <button id="resultsCloseBtn">Cerrar</button>
            </div>
        </div>
    </div>

    <a href="ayuda.html" class="help-btn">?</a>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const nodeNameInput = document.getElementById('nodeName');
            const nodeValueInput = document.getElementById('nodeValue');
            const createNodeBtn = document.getElementById('createNodeBtn');
            const editNodeBtn = document.getElementById('editNodeBtn');
            const deleteNodeBtn = document.getElementById('deleteNodeBtn');
            const edgeTypeSelect = document.getElementById('edgeType');
            const edgeWeightInput = document.getElementById('edgeWeight');
            const createEdgeBtn = document.getElementById('createEdgeBtn');
            const deleteEdgeBtn = document.getElementById('deleteEdgeBtn');
            const editEdgeBtn = document.getElementById('editEdgeBtn');
            const graphNameInput = document.getElementById('graphName');
            const saveGraphBtn = document.getElementById('saveGraphBtn');
            const loadGraphInput = document.getElementById('loadGraph');
            const selectModeBtn = document.getElementById('selectMode');
            const createModeBtn = document.getElementById('createMode');
            const connectModeBtn = document.getElementById('connectMode');
            const clearAllBtn = document.getElementById('clearAllBtn');
            const contextMenu = document.getElementById('contextMenu');
            const contextMenuEdge = document.getElementById('contextMenuEdge');
            const adjacencyMatrixDiv = document.getElementById('adjacencyMatrix');
            const statusBar = document.getElementById('statusBar');
            const colorPicker = document.getElementById('colorPicker');
            const printMatrixBtn = document.getElementById('printMatrixBtn');
            const printModal = document.getElementById('printModal');
            const printMatrixContent = document.getElementById('printMatrixContent');
            const printCloseBtn = document.getElementById('printCloseBtn');
            const printActualBtn = document.getElementById('printActualBtn');
            const johnsonBtn = document.getElementById('johnsonBtn');
            const showResultsBtn = document.getElementById('showResultsBtn');
            const clearResultsBtn = document.getElementById('clearResultsBtn');
            const resultsModal = document.getElementById('resultsModal');
            const resultsInfo = document.getElementById('resultsInfo');
            const resultsCloseBtn = document.getElementById('resultsCloseBtn');
            
            // Elementos del men√∫ contextual
            const ctxEditNode = document.getElementById('ctxEditNode');
            const ctxDeleteNode = document.getElementById('ctxDeleteNode');
            const ctxCreateEdge = document.getElementById('ctxCreateEdge');
            const ctxDeleteEdge = document.getElementById('ctxDeleteEdge');
            const ctxEditEdge = document.getElementById('ctxEditEdge');
            const ctxChangeColor = document.getElementById('ctxChangeColor');

            let nodes = [];
            let edges = [];
            let selectedNode = null;
            let isDragging = false;
            let dragStartX, dragStartY;
            let connectingNodes = false;
            let edgeStartNode = null;
            let mode = 'select'; // 'select', 'create' o 'connect'
            let rightClickTarget = null;
            let rightClickEdge = null;
            let selectedColor = '#7c83fd'; // Color por defecto
            let johnsonResults = null; // Almacena los resultados del algoritmo de Johnson
            let criticalPaths = []; // Almacena las rutas cr√≠ticas identificadas

            // Ajustar el tama√±o del canvas
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                drawGraph();
            }

            // Inicializar
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Clase Nodo
            class Node {
                constructor(id, name, value, x, y, color = '#7c83fd') {
                    this.id = id;
                    this.name = name;
                    this.value = value;
                    this.x = x;
                    this.y = y;
                    this.radius = 30;
                    this.color = color;
                    this.isHighlighted = false;
                    this.isCritical = false;
                }

                draw(ctx) {
                    // Dibujar c√≠rculo del nodo
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    
                    if (this.isCritical) {
                        ctx.fillStyle = this.getCriticalColor();
                    } else if (this.isHighlighted) {
                        ctx.fillStyle = this.getHighlightedColor();
                    } else {
                        ctx.fillStyle = this === selectedNode ? this.getSelectedColor() : this.color;
                    }
                    
                    ctx.fill();
                    ctx.strokeStyle = this.getBorderColor();
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Dibujar texto
                    ctx.font = 'bold 16px Arial';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Mostrar distancia si est√° disponible
                    let displayText = this.name;
                    if (this.distance !== undefined) {
                        displayText += `\n${this.distance}`;
                        ctx.font = 'bold 14px Arial';
                    }
                    
                    ctx.fillText(displayText, this.x, this.y);
                }
                
                getSelectedColor() {
                    // Aclarar el color para el nodo seleccionado
                    const hex = this.color.replace('#', '');
                    const r = parseInt(hex.substring(0, 2), 16);
                    const g = parseInt(hex.substring(2, 4), 16);
                    const b = parseInt(hex.substring(4, 6), 16);
                    
                    // Aumentar brillo en 30%
                    const brighterR = Math.min(255, Math.floor(r * 1.3));
                    const brighterG = Math.min(255, Math.floor(g * 1.3));
                    const brighterB = Math.min(255, Math.floor(b * 1.3));
                    
                    return `rgb(${brighterR}, ${brighterG}, ${brighterB})`;
                }
                
                getHighlightedColor() {
                    // Color especial para nodos destacados
                    const hex = this.color.replace('#', '');
                    const r = parseInt(hex.substring(0, 2), 16);
                    const g = parseInt(hex.substring(2, 4), 16);
                    const b = parseInt(hex.substring(4, 6), 16);
                    
                    // Cambiar a tono p√∫rpura para destacar
                    const purpleR = Math.min(255, Math.floor(r * 0.7 + 100));
                    const purpleG = Math.min(255, Math.floor(g * 0.7 + 50));
                    const purpleB = Math.min(255, Math.floor(b * 0.7 + 150));
                    
                    return `rgb(${purpleR}, ${purpleG}, ${purpleB})`;
                }
                
                getCriticalColor() {
                    // Color rojo para nodos cr√≠ticos
                    const hex = this.color.replace('#', '');
                    const r = parseInt(hex.substring(0, 2), 16);
                    const g = parseInt(hex.substring(2, 4), 16);
                    const b = parseInt(hex.substring(4, 6), 16);
                    
                    // Cambiar a tono rojo para nodos cr√≠ticos
                    const redR = Math.min(255, Math.floor(r * 0.5 + 200));
                    const redG = Math.min(255, Math.floor(g * 0.5));
                    const redB = Math.min(255, Math.floor(b * 0.5));
                    
                    return `rgb(${redR}, ${redG}, ${redB})`;
                }
                
                getBorderColor() {
                    // Oscurecer el color para el borde
                    const hex = this.color.replace('#', '');
                    const r = parseInt(hex.substring(0, 2), 16);
                    const g = parseInt(hex.substring(2, 4), 16);
                    const b = parseInt(hex.substring(4, 6), 16);
                    
                    // Reducir brillo en 20%
                    const darkerR = Math.max(0, Math.floor(r * 0.8));
                    const darkerG = Math.max(0, Math.floor(g * 0.8));
                    const darkerB = Math.max(0, Math.floor(b * 0.8));
                    
                    return `rgb(${darkerR}, ${darkerG}, ${darkerB})`;
                }

                isPointInside(x, y) {
                    return Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2) <= this.radius;
                }
                
                changeColor(newColor) {
                    this.color = newColor;
                    drawGraph();
                }
                
                highlight() {
                    this.isHighlighted = true;
                }
                
                unhighlight() {
                    this.isHighlighted = false;
                }
                
                markCritical() {
                    this.isCritical = true;
                }
                
                unmarkCritical() {
                    this.isCritical = false;
                }
            }

            // Clase Arista
            class Edge {
                constructor(from, to, directed = false, weight = 1) {
                    this.from = from;
                    this.to = to;
                    this.directed = directed;
                    this.weight = weight;
                    this.isHighlighted = false;
                    this.isCritical = false;
                }

                draw(ctx) {
                    const fromX = this.from.x;
                    const fromY = this.from.y;
                    const toX = this.to.x;
                    const toY = this.to.y;

                    // Calcular √°ngulo y puntos de conexi√≥n
                    const angle = Math.atan2(toY - fromY, toX - fromX);
                    const fromRadius = this.from.radius;
                    const toRadius = this.to.radius;

                    // Ajustar puntos de inicio y fin para que est√©n en el borde del nodo
                    const startX = fromX + fromRadius * Math.cos(angle);
                    const startY = fromY + fromRadius * Math.sin(angle);
                    const endX = toX - toRadius * Math.cos(angle);
                    const endY = toY - toRadius * Math.sin(angle);

                    // Dibujar l√≠nea curva para aristas entre nodos diferentes
                    if (this.from !== this.to) {
                        // Calcular punto de control para la curva
                        const midX = (startX + endX) / 2;
                        const midY = (startY + endY) / 2;
                        
                        // Desplazar el punto medio para crear una curva
                        const curveIntensity = 30;
                        const ctrlX = midX + curveIntensity * Math.sin(angle);
                        const ctrlY = midY - curveIntensity * Math.cos(angle);
                        
                        // Dibujar curva
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
                        
                        if (this.isCritical) {
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 4;
                        } else if (this.isHighlighted) {
                            ctx.strokeStyle = '#9b59b6';
                            ctx.lineWidth = 4;
                        } else {
                            ctx.strokeStyle = this === rightClickEdge ? '#ff6b6b' : '#7c83fd';
                            ctx.lineWidth = this === rightClickEdge ? 3 : 2;
                        }
                        
                        ctx.stroke();

                        // Dibujar flecha si es dirigida
                        if (this.directed) {
                            const arrowLength = 10;
                            const arrowAngle = Math.PI / 6;

                            // Calcular punto en la curva para colocar la flecha
                            const t = 0.8; // Posici√≥n a lo largo de la curva (0 a 1)
                            const tx = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * ctrlX + t * t * endX;
                            const ty = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * ctrlY + t * t * endY;
                            
                            // Calcular √°ngulo de la tangente en ese punto
                            const dx = 2 * (1 - t) * (ctrlX - startX) + 2 * t * (endX - ctrlX);
                            const dy = 2 * (1 - t) * (ctrlY - startY) + 2 * t * (endY - ctrlY);
                            const tangentAngle = Math.atan2(dy, dx);
                            
                            // Dibujar flecha
                            ctx.beginPath();
                            ctx.moveTo(tx, ty);
                            ctx.lineTo(
                                tx - arrowLength * Math.cos(tangentAngle - arrowAngle),
                                ty - arrowLength * Math.sin(tangentAngle - arrowAngle)
                            );
                            ctx.lineTo(
                                tx - arrowLength * Math.cos(tangentAngle + arrowAngle),
                                ty - arrowLength * Math.sin(tangentAngle + arrowAngle)
                            );
                            ctx.closePath();
                            
                            if (this.isCritical) {
                                ctx.fillStyle = '#e74c3c';
                            } else if (this.isHighlighted) {
                                ctx.fillStyle = '#9b59b6';
                            } else {
                                ctx.fillStyle = this === rightClickEdge ? '#ff6b6b' : '#7c83fd';
                            }
                            
                            ctx.fill();
                        }
                    } else {
                        // Dibujar bucle para un nodo conectado a s√≠ mismo
                        const loopRadius = 30;
                        ctx.beginPath();
                        ctx.arc(fromX, fromY - fromRadius, loopRadius, Math.PI * 0.8, Math.PI * 2.2, false);
                        
                        if (this.isCritical) {
                            ctx.strokeStyle = '#e74c3c';
                            ctx.lineWidth = 4;
                        } else if (this.isHighlighted) {
                            ctx.strokeStyle = '#9b59b6';
                            ctx.lineWidth = 4;
                        } else {
                            ctx.strokeStyle = this === rightClickEdge ? '#ff6b6b' : '#7c83fd';
                            ctx.lineWidth = this === rightClickEdge ? 3 : 2;
                        }
                        
                        ctx.stroke();

                        // Dibujar flecha si es dirigida
                        if (this.directed) {
                            const arrowLength = 10;
                            const arrowAngle = Math.PI / 6;
                            const arrowX = fromX + loopRadius * Math.cos(Math.PI * 1.7);
                            const arrowY = fromY - fromRadius + loopRadius * Math.sin(Math.PI * 1.7);
                            
                            ctx.beginPath();
                            ctx.moveTo(arrowX, arrowY);
                            ctx.lineTo(
                                arrowX - arrowLength * Math.cos(Math.PI * 1.7 - arrowAngle),
                                arrowY - arrowLength * Math.sin(Math.PI * 1.7 - arrowAngle)
                            );
                            ctx.lineTo(
                                arrowX - arrowLength * Math.cos(Math.PI * 1.7 + arrowAngle),
                                arrowY - arrowLength * Math.sin(Math.PI * 1.7 + arrowAngle)
                            );
                            ctx.closePath();
                            
                            if (this.isCritical) {
                                ctx.fillStyle = '#e74c3c';
                            } else if (this.isHighlighted) {
                                ctx.fillStyle = '#9b59b6';
                            } else {
                                ctx.fillStyle = this === rightClickEdge ? '#ff6b6b' : '#7c83fd';
                            }
                            
                            ctx.fill();
                        }
                    }

                    // Dibujar peso
                    let midX, midY;
                    if (this.from !== this.to) {
                        midX = (startX + endX) / 2;
                        midY = (startY + endY) / 2;
                        // Ajustar posici√≥n del peso para curvas
                        midX += 20 * Math.sin(angle);
                        midY -= 20 * Math.cos(angle);
                    } else {
                        midX = fromX;
                        midY = fromY - fromRadius - 20;
                    }
                    
                    // Fondo para el peso
                    ctx.font = 'bold 14px Arial';
                    const text = this.weight.toString();
                    const textWidth = ctx.measureText(text).width;
                    
                    if (this.isCritical) {
                        ctx.fillStyle = 'rgba(231, 76, 60, 0.8)';
                    } else if (this.isHighlighted) {
                        ctx.fillStyle = 'rgba(155, 89, 182, 0.8)';
                    } else {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    }
                    
                    ctx.fillRect(midX - textWidth/2 - 4, midY - 12, textWidth + 8, 20);
                    
                    // Texto del peso
                    ctx.fillStyle = this.isCritical || this.isHighlighted ? 'white' : '#4a5568';
                    ctx.fillText(text, midX, midY + 2);
                }

                isPointNearLine(x, y, threshold = 10) { // Aumentado de 5 a 10 para mejor selecci√≥n
                    const fromX = this.from.x;
                    const fromY = this.from.y;
                    const toX = this.to.x;
                    const toY = this.to.y;
                    
                    // Para bucles (mismo nodo)
                    if (this.from === this.to) {
                        const loopCenterX = fromX;
                        const loopCenterY = fromY - this.from.radius;
                        const loopRadius = 30;
                        
                        // Calcular distancia al centro del bucle
                        const distance = Math.sqrt((x - loopCenterX) ** 2 + (y - loopCenterY) ** 2);
                        return Math.abs(distance - loopRadius) < threshold;
                    }
                    
                    // Para aristas entre nodos diferentes
                    // Calcular la distancia del punto a la l√≠nea
                    const A = x - fromX;
                    const B = y - fromY;
                    const C = toX - fromX;
                    const D = toY - fromY;
                    
                    const dot = A * C + B * D;
                    const len_sq = C * C + D * D;
                    let param = -1;
                    if (len_sq !== 0) {
                        param = dot / len_sq;
                    }
                    
                    let xx, yy;
                    
                    if (param < 0) {
                        xx = fromX;
                        yy = fromY;
                    } else if (param > 1) {
                        xx = toX;
                        yy = toY;
                    } else {
                        xx = fromX + param * C;
                        yy = fromY + param * D;
                    }
                    
                    const dx = x - xx;
                    const dy = y - yy;
                    return Math.sqrt(dx * dx + dy * dy) < threshold;
                }
                
                highlight() {
                    this.isHighlighted = true;
                }
                
                unhighlight() {
                    this.isHighlighted = false;
                }
                
                markCritical() {
                    this.isCritical = true;
                }
                
                unmarkCritical() {
                    this.isCritical = false;
                }
            }

            // Dibujar el grafo completo
            function drawGraph() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Dibujar aristas primero (debajo de los nodos)
                edges.forEach(edge => edge.draw(ctx));
                
                // Dibujar nodos
                nodes.forEach(node => node.draw(ctx));
                
                // Si estamos creando una arista, dibujar una l√≠nea temporal
                if (connectingNodes && edgeStartNode) {
                    ctx.beginPath();
                    ctx.moveTo(edgeStartNode.x, edgeStartNode.y);
                    ctx.lineTo(dragStartX, dragStartY);
                    ctx.strokeStyle = '#7c83fd';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Actualizar matriz de adyacencia
                updateAdjacencyMatrix();
            }

            // Crear un nuevo nodo
            function createNode() {
                const name = nodeNameInput.value.trim() || `N${nodes.length + 1}`;
                const value = nodeValueInput.value.trim() || '';
                
                // Posici√≥n aleatoria dentro del canvas (con m√°rgenes)
                const margin = 50;
                const x = margin + Math.random() * (canvas.width - 2 * margin);
                const y = margin + Math.random() * (canvas.height - 2 * margin);
                
                const newNode = new Node(Date.now(), name, value, x, y, selectedColor);
                nodes.push(newNode);
                
                // Limpiar campos
                nodeNameInput.value = '';
                nodeValueInput.value = '';
                
                drawGraph();
            }

            // Editar nodo seleccionado
            function editSelectedNode() {
                if (!selectedNode) {
                    alert('Por favor, seleccione un nodo para editar.');
                    return;
                }
                
                const newName = prompt('Nuevo nombre del nodo:', selectedNode.name);
                if (newName !== null) {
                    selectedNode.name = newName.trim() || selectedNode.name;
                    
                    const newValue = prompt('Nuevo valor del nodo:', selectedNode.value);
                    if (newValue !== null) {
                        selectedNode.value = newValue.trim();
                    }
                    
                    drawGraph();
                }
            }

            // Eliminar nodo seleccionado
            function deleteSelectedNode() {
                if (!selectedNode) {
                    alert('Por favor, seleccione un nodo para eliminar.');
                    return;
                }
                
                if (confirm(`¬øEst√° seguro de que deseta eliminar el nodo "${selectedNode.name}"?`)) {
                    // Eliminar el nodo
                    nodes = nodes.filter(node => node !== selectedNode);
                    
                    // Eliminar todas las aristas conectadas a este nodo
                    edges = edges.filter(edge => 
                        edge.from !== selectedNode && edge.to !== selectedNode
                    );
                    
                    selectedNode = null;
                    drawGraph();
                }
            }

            // Crear una arista entre dos nodos
            function createEdge(fromNode, toNode) {
                if (!fromNode || !toNode) {
                    alert('Debe seleccionar dos nodos para crear una arista.');
                    return;
                }
                
                // Verificar si la arista ya existe
                const edgeExists = edges.some(edge => {
                    if (edge.directed) {
                        return edge.from === fromNode && edge.to === toNode;
                    } else {
                        return (edge.from === fromNode && edge.to === toNode) ||
                               (edge.from === toNode && edge.to === fromNode);
                    }
                });
                
                if (edgeExists) {
                    alert('Ya existe una arista entre estos nodos.');
                    return;
                }
                
                // Validar peso
                let weight = parseInt(edgeWeightInput.value);
                if (isNaN(weight) || weight < 1) {
                    alert('El peso debe ser un n√∫mero positivo mayor que 0.');
                    edgeWeightInput.value = '1';
                    weight = 1;
                }
                
                const directed = edgeTypeSelect.value === 'directed';
                
                edges.push(new Edge(fromNode, toNode, directed, weight));
                drawGraph();
            }

            // Eliminar arista entre dos nodos
            function deleteEdge(fromNode, toNode) {
                if (!fromNode || !toNode) {
                    // Si no se proporcionan nodos, usar la arista seleccionada con click derecho
                    if (rightClickEdge) {
                        const index = edges.indexOf(rightClickEdge);
                        if (index !== -1) {
                            edges.splice(index, 1);
                            drawGraph();
                            return;
                        }
                    }
                    alert('Debe seleccionar dos nodos conectados para eliminar la arista.');
                    return;
                }
                
                // Buscar y eliminar la arista
                const edgeIndex = edges.findIndex(edge => 
                    (edge.from === fromNode && edge.to === toNode) ||
                    (edge.from === toNode && edge.to === fromNode)
                );
                
                if (edgeIndex === -1) {
                    alert('No existe una arista entre estos nodos.');
                    return;
                }
                
                edges.splice(edgeIndex, 1);
                drawGraph();
            }

            // Editar arista seleccionada
            function editSelectedEdge() {
                if (!rightClickEdge) {
                    alert('Por favor, seleccione una arista para editar (click derecho).');
                    return;
                }
                
                const newWeight = prompt('Nuevo peso de la arista:', rightClickEdge.weight);
                if (newWeight !== null && !isNaN(newWeight) && newWeight !== '' && parseInt(newWeight) > 0) {
                    rightClickEdge.weight = parseInt(newWeight);
                    drawGraph();
                } else if (newWeight !== null) {
                    alert('El peso debe ser un n√∫mero positivo mayor que 0.');
                }
            }

            // Cambiar color del nodo seleccionado
            function changeNodeColor() {
                if (!selectedNode) {
                    alert('Por favor, seleccione un nodo para cambiar su color.');
                    return;
                }
                
                const newColor = prompt('Ingrese el color en hexadecimal (ej: #ff0000):', selectedNode.color);
                if (newColor !== null && /^#([0-9A-F]{3}){1,2}$/i.test(newColor)) {
                    selectedNode.changeColor(newColor);
                } else if (newColor !== null) {
                    alert('Por favor, ingrese un color hexadecimal v√°lido (ej: #ff0000).');
                }
            }

            // Limpiar todo el grafo
            function clearAll() {
                if (confirm('¬øEst√° seguro de que desea eliminar todos los nodos y aristas?')) {
                    nodes = [];
                    edges = [];
                    selectedNode = null;
                    rightClickEdge = null;
                    johnsonResults = null;
                    criticalPaths = [];
                    drawGraph();
                }
            }

            // Guardar grafo en un archivo JSON
            function saveGraph() {
                const graphName = graphNameInput.value.trim() || `grafo_${new Date().getTime()}`;
                
                const graphData = {
                    name: graphName,
                    nodes: nodes.map(node => ({
                        id: node.id,
                        name: node.name,
                        value: node.value,
                        x: node.x,
                        y: node.y,
                        color: node.color
                    })),
                    edges: edges.map(edge => ({
                        fromId: edge.from.id,
                        toId: edge.to.id,
                        directed: edge.directed,
                        weight: edge.weight
                    }))
                };
                
                const dataStr = JSON.stringify(graphData);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = `${graphName}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }

            // Cargar grafo desde un archivo JSON
            function loadGraph(file) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const graphData = JSON.parse(e.target.result);
                        
                        // Limpiar grafo actual
                        nodes = [];
                        edges = [];
                        selectedNode = null;
                        johnsonResults = null;
                        criticalPaths = [];
                        
                        // Restaurar nodos
                        graphData.nodes.forEach(nodeData => {
                            const node = new Node(
                                nodeData.id,
                                nodeData.name,
                                nodeData.value,
                                nodeData.x,
                                nodeData.y,
                                nodeData.color || '#7c83fd' // Color por defecto si no existe
                            );
                            nodes.push(node);
                        });
                        
                        // Restaurar aristas
                        graphData.edges.forEach(edgeData => {
                            const fromNode = nodes.find(n => n.id === edgeData.fromId);
                            const toNode = nodes.find(n => n.id === edgeData.toId);
                            
                            if (fromNode && toNode) {
                                const edge = new Edge(
                                    fromNode,
                                    toNode,
                                    edgeData.directed,
                                    edgeData.weight
                                );
                                edges.push(edge);
                            }
                        });
                        
                        graphNameInput.value = graphData.name;
                        drawGraph();
                    } catch (error) {
                        alert('Error al cargar el archivo: ' + error.message);
                    }
                };
                
                reader.readAsText(file);
            }

            // Actualizar la matriz de adyacencia
            function updateAdjacencyMatrix() {
                if (nodes.length === 0) {
                    adjacencyMatrixDiv.innerHTML = '<p>No hay nodos en el grafo</p>';
                    return;
                }
                
                // Ordenar nodos por nombre
                const sortedNodes = [...nodes].sort((a, b) => a.name.localeCompare(b.name));
                
                let tableHTML = '<table class="matrix-table"><tr><th></th>';
                
                // Encabezados de columnas
                sortedNodes.forEach(node => {
                    tableHTML += `<th>${node.name}</th>`;
                });
                tableHTML += '</tr>';
                
                // Filas de la matriz
                sortedNodes.forEach(fromNode => {
                    tableHTML += `<tr><th>${fromNode.name}</th>`;
                    
                    sortedNodes.forEach(toNode => {
                        let value = 0;
                        
                        // Buscar aristas entre fromNode y toNode
                        const edge = edges.find(e => {
                            if (e.directed) {
                                return e.from === fromNode && e.to === toNode;
                            } else {
                                return (e.from === fromNode && e.to === toNode) ||
                                       (e.from === toNode && e.to === fromNode);
                            }
                        });
                        
                        if (edge) {
                            value = edge.weight;
                        }
                        
                        tableHTML += `<td>${value}</td>`;
                    });
                    
                    tableHTML += '</tr>';
                });
                
                tableHTML += '</table>';
                adjacencyMatrixDiv.innerHTML = tableHTML;
            }
            
            // Mostrar modal para imprimir matriz
            function showPrintModal() {
                if (nodes.length === 0) {
                    alert('No hay nodos en el grafo para imprimir la matriz.');
                    return;
                }
                
                // Clonar el contenido de la matriz para el modal
                printMatrixContent.innerHTML = adjacencyMatrixDiv.innerHTML;
                
                // Mostrar el modal
                printModal.style.display = 'flex';
            }
            
            // Imprimir la matriz
            function printMatrix() {
                const printContent = printMatrixContent.innerHTML;
                const originalContent = document.body.innerHTML;
                
                document.body.innerHTML = `
                    <h1>Matriz de Adyacencia - ${graphNameInput.value || 'Grafo'}</h1>
                    ${printContent}
                `;
                
                window.print();
                
                // Restaurar el contenido original
                document.body.innerHTML = originalContent;
                
                // Volver a vincular eventos
                bindEvents();
                
                // Cerrar el modal
                printModal.style.display = 'none';
            }
            
            // Implementaci√≥n del algoritmo de Johnson
            function johnsonAlgorithm() {
                if (nodes.length === 0) {
                    alert('No hay nodos en el grafo para ejecutar el algoritmo.');
                    return;
                }
                
                // Limpiar resultados anteriores
                clearJohnsonResults();
                
                // Crear un mapeo de nodos a √≠ndices
                const nodeIndexMap = new Map();
                nodes.forEach((node, index) => {
                    nodeIndexMap.set(node, index);
                });
                
                const n = nodes.length;
                
                // Inicializar matriz de distancias
                const dist = Array(n).fill().map(() => Array(n).fill(Infinity));
                
                // Inicializar matriz de predecesores
                const next = Array(n).fill().map(() => Array(n).fill(null));
                
                // Configurar distancias iniciales
                for (let i = 0; i < n; i++) {
                    dist[i][i] = 0;
                    next[i][i] = i;
                }
                
                // Llenar la matriz con los pesos de las aristas
                edges.forEach(edge => {
                    const u = nodeIndexMap.get(edge.from);
                    const v = nodeIndexMap.get(edge.to);
                    
                    if (u !== undefined && v !== undefined) {
                        if (edge.directed) {
                            // Arista dirigida
                            if (dist[u][v] > edge.weight) {
                                dist[u][v] = edge.weight;
                                next[u][v] = v;
                            }
                        } else {
                            // Arista no dirigida (bidireccional)
                            if (dist[u][v] > edge.weight) {
                                dist[u][v] = edge.weight;
                                next[u][v] = v;
                            }
                            if (dist[v][u] > edge.weight) {
                                dist[v][u] = edge.weight;
                                next[v][u] = u;
                            }
                        }
                    }
                });
                
                // Algoritmo de Floyd-Warshall
                for (let k = 0; k < n; k++) {
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            if (dist[i][k] + dist[k][j] < dist[i][j]) {
                                dist[i][j] = dist[i][k] + dist[k][j];
                                next[i][j] = next[i][k];
                            }
                        }
                    }
                }
                
                // Almacenar resultados
                johnsonResults = {
                    distances: dist,
                    next: next,
                    nodeIndexMap: nodeIndexMap
                };
                
                // Encontrar y marcar rutas cr√≠ticas
                findCriticalPaths(dist, next, nodeIndexMap);
                
                // Mostrar resultados
                showJohnsonResults();
                
                // Destacar el nodo con la distancia m√°s corta promedio (centro del grafo)
                highlightGraphCenter(dist, nodeIndexMap);
            }
            
            // Encontrar rutas cr√≠ticas en el grafo
            function findCriticalPaths(dist, next, nodeIndexMap) {
                const n = nodes.length;
                criticalPaths = [];
                
                // Encontrar el di√°metro del grafo (la distancia m√°s larga entre dos nodos)
                let maxDistance = -Infinity;
                let startNodeIdx = -1;
                let endNodeIdx = -1;
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (dist[i][j] !== Infinity && dist[i][j] > maxDistance) {
                            maxDistance = dist[i][j];
                            startNodeIdx = i;
                            endNodeIdx = j;
                        }
                    }
                }
                
                if (startNodeIdx !== -1 && endNodeIdx !== -1) {
                    // Reconstruir el camino m√°s largo (di√°metro)
                    const criticalPath = reconstructPath(startNodeIdx, endNodeIdx);
                    
                    if (criticalPath.length > 0) {
                        criticalPaths.push(criticalPath);
                        
                        // Marcar nodos y aristas como cr√≠ticos
                        markCriticalPath(criticalPath);
                    }
                }
                
                // Encontrar otras rutas importantes (aquellas con distancia superior al 80% del m√°ximo)
                const threshold = maxDistance * 0.8;
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (i !== j && dist[i][j] !== Infinity && dist[i][j] >= threshold) {
                            const path = reconstructPath(i, j);
                            
                            // Solo considerar caminos que no sean subconjuntos de caminos ya identificados
                            if (!isSubPath(path, criticalPaths)) {
                                criticalPaths.push(path);
                                markCriticalPath(path);
                            }
                        }
                    }
                }
            }
            
            // Reconstruir el camino entre dos nodos
            function reconstructPath(u, v) {
                if (johnsonResults.next[u][v] === null) return [];
                
                const path = [u];
                
                while (u !== v) {
                    u = johnsonResults.next[u][v];
                    path.push(u);
                }
                
                return path;
            }
            
            // Verificar si un camino es subcamino de alguno en una lista
            function isSubPath(path, pathList) {
                for (const existingPath of pathList) {
                    if (isSubsequence(path, existingPath)) {
                        return true;
                    }
                }
                return false;
            }
            
            // Verificar si una secuencia es subsecuencia de otra
            function isSubsequence(sub, full) {
                if (sub.length > full.length) return false;
                
                let i = 0;
                for (let j = 0; j < full.length && i < sub.length; j++) {
                    if (sub[i] === full[j]) {
                        i++;
                    }
                }
                return i === sub.length;
            }
            
            // Marcar un camino como cr√≠tico
            function markCriticalPath(path) {
                // Marcar nodos
                for (const nodeIdx of path) {
                    nodes[nodeIdx].markCritical();
                }
                
                // Marcar aristas
                for (let i = 0; i < path.length - 1; i++) {
                    const fromIdx = path[i];
                    const toIdx = path[i + 1];
                    
                    const fromNode = nodes[fromIdx];
                    const toNode = nodes[toIdx];
                    
                    // Buscar la arista entre estos nodos
                    const edge = edges.find(e => 
                        (e.from === fromNode && e.to === toNode) || 
                        (e.from === toNode && e.to === fromNode)
                    );
                    
                    if (edge) {
                        edge.markCritical();
                    }
                }
            }
            
            // Mostrar resultados del algoritmo de Johnson
            function showJohnsonResults() {
                if (!johnsonResults) {
                    alert('Primero debe ejecutar el algoritmo de Johnson.');
                    return;
                }
                
                const { distances, nodeIndexMap } = johnsonResults;
                const n = nodes.length;
                
                // Crear tabla de resultados
                let resultsHTML = '<h3>Distancias m√°s cortas entre todos los pares de nodos</h3>';
                resultsHTML += '<table class="results-table"><tr><th></th>';
                
                // Encabezados de columnas
                nodes.forEach(node => {
                    resultsHTML += `<th>${node.name}</th>`;
                });
                resultsHTML += '</tr>';
                
                // Filas de la tabla
                nodes.forEach((node, i) => {
                    resultsHTML += `<tr><th>${node.name}</th>`;
                    
                    nodes.forEach((_, j) => {
                        const distance = distances[i][j];
                        resultsHTML += `<td>${distance === Infinity ? '‚àû' : distance}</td>`;
                    });
                    
                    resultsHTML += '</tr>';
                });
                
                resultsHTML += '</table>';
                
                // Informaci√≥n adicional
                resultsHTML += '<div class="path-info">';
                resultsHTML += '<h3>Informaci√≥n del Grafo</h3>';
                
                // Calcular el di√°metro del grafo (distancia m√°s larga entre dos nodos)
                let diameter = 0;
                let startNode = null;
                let endNode = null;
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (distances[i][j] !== Infinity && distances[i][j] > diameter) {
                            diameter = distances[i][j];
                            startNode = nodes[i];
                            endNode = nodes[j];
                        }
                    }
                }
                
                if (startNode && endNode) {
                    resultsHTML += `<p><strong>Di√°metro del grafo:</strong> ${diameter} (de ${startNode.name} a ${endNode.name})</p>`;
                }
                
                // Mostrar informaci√≥n sobre rutas cr√≠ticas
                if (criticalPaths.length > 0) {
                    resultsHTML += '<div class="critical-path">';
                    resultsHTML += '<h3>üî¥ Rutas Cr√≠ticas Identificadas</h3>';
                    
                    criticalPaths.forEach((path, index) => {
                        const pathNames = path.map(idx => nodes[idx].name).join(' ‚Üí ');
                        const pathDistance = distances[path[0]][path[path.length - 1]];
                        resultsHTML += `<p><strong>Ruta ${index + 1}:</strong> ${pathNames} (distancia: ${pathDistance})</p>`;
                    });
                    
                    resultsHTML += '</div>';
                }
                
                resultsHTML += '</div>';
                
                resultsInfo.innerHTML = resultsHTML;
                resultsModal.style.display = 'flex';
                
                // Redibujar el grafo para mostrar los elementos cr√≠ticos
                drawGraph();
            }
            
            // Destacar el centro del grafo (nodo con la distancia promedio m√°s corta)
            function highlightGraphCenter(distances, nodeIndexMap) {
                // Calcular la distancia promedio para cada nodo
                const avgDistances = [];
                
                for (let i = 0; i < nodes.length; i++) {
                    let sum = 0;
                    let count = 0;
                    
                    for (let j = 0; j < nodes.length; j++) {
                        if (i !== j && distances[i][j] !== Infinity) {
                            sum += distances[i][j];
                            count++;
                        }
                    }
                    
                    const avg = count > 0 ? sum / count : Infinity;
                    avgDistances.push(avg);
                    
                    // Asignar la distancia promedio al nodo para mostrarla
                    nodes[i].distance = avg !== Infinity ? avg.toFixed(2) : '‚àû';
                }
                
                // Encontrar el nodo con la distancia promedio m√≠nima
                let minAvg = Infinity;
                let centerNodeIndex = -1;
                
                for (let i = 0; i < avgDistances.length; i++) {
                    if (avgDistances[i] < minAvg) {
                        minAvg = avgDistances[i];
                        centerNodeIndex = i;
                    }
                }
                
                // Destacar el nodo centro
                if (centerNodeIndex !== -1) {
                    nodes[centerNodeIndex].highlight();
                    
                    // Tambi√©n destacar las aristas conectadas al nodo centro
                    edges.forEach(edge => {
                        if (edge.from === nodes[centerNodeIndex] || edge.to === nodes[centerNodeIndex]) {
                            edge.highlight();
                        }
                    });
                    
                    drawGraph();
                    
                    // Mostrar informaci√≥n en la barra de estado
                    statusBar.textContent = `Centro del grafo: ${nodes[centerNodeIndex].name} (distancia promedio: ${minAvg.toFixed(2)})`;
                }
            }
            
            // Limpiar resultados de Johnson
            function clearJohnsonResults() {
                johnsonResults = null;
                criticalPaths = [];
                
                // Quitar destacados y distancias
                nodes.forEach(node => {
                    node.unhighlight();
                    node.unmarkCritical();
                    delete node.distance;
                });
                
                edges.forEach(edge => {
                    edge.unhighlight();
                    edge.unmarkCritical();
                });
                
                drawGraph();
                statusBar.textContent = 'Resultados de Johnson eliminados';
            }

            // Mostrar men√∫ contextual para nodos
            function showNodeContextMenu(x, y, node) {
                rightClickTarget = node;
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
            }

            // Mostrar men√∫ contextual para aristas
            function showEdgeContextMenu(x, y, edge) {
                rightClickEdge = edge;
                contextMenuEdge.style.display = 'block';
                contextMenuEdge.style.left = `${x}px`;
                contextMenuEdge.style.top = `${y}px`;
            }

            // Ocultar todos los men√∫s contextuales
            function hideContextMenus() {
                contextMenu.style.display = 'none';
                contextMenuEdge.style.display = 'none';
                rightClickTarget = null;
                rightClickEdge = null;
                drawGraph();
            }

            // Cambiar modo de interacci√≥n
            function setMode(newMode) {
                mode = newMode;
                selectModeBtn.classList.toggle('active', mode === 'select');
                createModeBtn.classList.toggle('active', mode === 'create');
                connectModeBtn.classList.toggle('active', mode === 'connect');
                
                // Actualizar barra de estado
                if (mode === 'select') {
                    statusBar.textContent = 'Modo: Seleccionar/Mover';
                } else if (mode === 'create') {
                    statusBar.textContent = 'Modo: Crear Nodos';
                } else if (mode === 'connect') {
                    statusBar.textContent = 'Modo: Conectar Nodos';
                }
                
                // Resetear estado de conexi√≥n
                connectingNodes = false;
                edgeStartNode = null;
            }
            
            // Vincular eventos (para restaurar despu√©s de imprimir)
            function bindEvents() {
                // Re-vincular todos los eventos necesarios
                createNodeBtn.addEventListener('click', createNode);
                editNodeBtn.addEventListener('click', editSelectedNode);
                deleteNodeBtn.addEventListener('click', deleteSelectedNode);
                createEdgeBtn.addEventListener('click', function() {
                    if (selectedNode) {
                        // En el modo de bot√≥n, necesitamos seleccionar el segundo nodo
                        statusBar.textContent = 'Haga clic en el segundo nodo para conectar';
                        connectingNodes = true;
                        edgeStartNode = selectedNode;
                    } else {
                        alert('Primero seleccione un nodo para iniciar la conexi√≥n.');
                    }
                });
                deleteEdgeBtn.addEventListener('click', function() {
                    if (selectedNode) {
                        statusBar.textContent = 'Haga clic en el segundo nodo para eliminar la conexi√≥n';
                        connectingNodes = true;
                        edgeStartNode = selectedNode;
                        mode = 'deleteEdge';
                    } else {
                        alert('Primero seleccione un nodo para iniciar la eliminaci√≥n.');
                    }
                });
                editEdgeBtn.addEventListener('click', editSelectedEdge);
                saveGraphBtn.addEventListener('click', saveGraph);
                clearAllBtn.addEventListener('click', clearAll);
                printMatrixBtn.addEventListener('click', showPrintModal);
                printCloseBtn.addEventListener('click', () => printModal.style.display = 'none');
                printActualBtn.addEventListener('click', printMatrix);
                johnsonBtn.addEventListener('click', johnsonAlgorithm);
                showResultsBtn.addEventListener('click', showJohnsonResults);
                clearResultsBtn.addEventListener('click', clearJohnsonResults);
                resultsCloseBtn.addEventListener('click', () => resultsModal.style.display = 'none');
                
                // Eventos de selecci√≥n de color
                document.querySelectorAll('.color-option').forEach(option => {
                    option.addEventListener('click', function() {
                        document.querySelectorAll('.color-option').forEach(opt => {
                            opt.classList.remove('selected');
                        });
                        this.classList.add('selected');
                        selectedColor = this.getAttribute('data-color');
                    });
                });
            }

            // Event Listeners
            bindEvents();
            
            loadGraphInput.addEventListener('change', function() {
                if (this.files && this.files[0]) {
                    loadGraph(this.files[0]);
                }
            });

            selectModeBtn.addEventListener('click', () => setMode('select'));
            createModeBtn.addEventListener('click', () => setMode('create'));
            connectModeBtn.addEventListener('click', () => setMode('connect'));

            // Eventos del men√∫ contextual para nodos
            ctxEditNode.addEventListener('click', function() {
                if (rightClickTarget) {
                    selectedNode = rightClickTarget;
                    editSelectedNode();
                }
                hideContextMenus();
            });

            ctxDeleteNode.addEventListener('click', function() {
                if (rightClickTarget) {
                    selectedNode = rightClickTarget;
                    deleteSelectedNode();
                }
                hideContextMenus();
            });

            ctxCreateEdge.addEventListener('click', function() {
                if (rightClickTarget) {
                    connectingNodes = true;
                    edgeStartNode = rightClickTarget;
                    setMode('connect');
                    statusBar.textContent = 'Haga clic en el segundo nodo para conectar';
                }
                hideContextMenus();
            });
            
            ctxChangeColor.addEventListener('click', function() {
                if (rightClickTarget) {
                    selectedNode = rightClickTarget;
                    changeNodeColor();
                }
                hideContextMenus();
            });

            // Eventos del men√∫ contextual para aristas
            ctxDeleteEdge.addEventListener('click', function() {
                if (rightClickEdge) {
                    deleteEdge(rightClickEdge.from, rightClickEdge.to);
                }
                hideContextMenus();
            });

            ctxEditEdge.addEventListener('click', function() {
                if (rightClickEdge) {
                    editSelectedEdge();
                }
                hideContextMenus();
            });

            // Eventos del canvas
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                dragStartX = x;
                dragStartY = y;
                
                // Verificar si se hizo clic en un nodo
                for (let i = nodes.length - 1; i >= 0; i--) {
                    if (nodes[i].isPointInside(x, y)) {
                        if (mode === 'select') {
                            selectedNode = nodes[i];
                            isDragging = true;
                        } else if (mode === 'connect') {
                            if (connectingNodes && edgeStartNode) {
                                // Segundo nodo seleccionado para conectar
                                createEdge(edgeStartNode, nodes[i]);
                                connectingNodes = false;
                                edgeStartNode = null;
                                setMode('connect');
                            } else {
                                // Primer nodo seleccionado para conectar
                                connectingNodes = true;
                                edgeStartNode = nodes[i];
                                statusBar.textContent = 'Haga clic en el segundo nodo para conectar';
                            }
                        } else if (mode === 'deleteEdge') {
                            if (edgeStartNode) {
                                // Segundo nodo seleccionado para eliminar conexi√≥n
                                deleteEdge(edgeStartNode, nodes[i]);
                                connectingNodes = false;
                                edgeStartNode = null;
                                setMode('select');
                            }
                        }
                        drawGraph();
                        return;
                    }
                }
                
                // Verificar si se hizo clic en una arista (con mayor sensibilidad)
                for (let i = edges.length - 1; i >= 0; i--) {
                    if (edges[i].isPointNearLine(x, y)) {
                        rightClickEdge = edges[i];
                        drawGraph();
                        return;
                    }
                }
                
                // Si no se hizo clic en un nodo y est√° en modo creaci√≥n, crear un nuevo nodo
                if (mode === 'create') {
                    nodeNameInput.value = `N${nodes.length + 1}`;
                    nodeValueInput.value = '';
                    createNode();
                } else {
                    selectedNode = null;
                    drawGraph();
                }
            });

            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Verificar si se hizo clic derecho en un nodo
                for (let i = nodes.length - 1; i >= 0; i--) {
                    if (nodes[i].isPointInside(x, y)) {
                        showNodeContextMenu(e.clientX, e.clientY, nodes[i]);
                        return;
                    }
                }
                
                // Verificar si se hizo clic derecho en una arista (con mayor sensibilidad)
                for (let i = edges.length - 1; i >= 0; i--) {
                    if (edges[i].isPointNearLine(x, y)) {
                        showEdgeContextMenu(e.clientX, e.clientY, edges[i]);
                        return;
                    }
                }
                
                // Si no se hizo clic en ning√∫n elemento, ocultar men√∫s contextuales
                hideContextMenus();
            });

            canvas.addEventListener('mousemove', function(e) {
                if (!isDragging || !selectedNode) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                selectedNode.x += x - dragStartX;
                selectedNode.y += y - dragStartY;
                
                // Limitar al √°rea del canvas
                selectedNode.x = Math.max(selectedNode.radius, Math.min(canvas.width - selectedNode.radius, selectedNode.x));
                selectedNode.y = Math.max(selectedNode.radius, Math.min(canvas.height - selectedNode.radius, selectedNode.y));
                
                dragStartX = x;
                dragStartY = y;
                
                drawGraph();
            });

            canvas.addEventListener('mouseup', function(e) {
                if (connectingNodes && edgeStartNode && mode === 'connect') {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Buscar si se solt√≥ sobre un nodo
                    for (let i = nodes.length - 1; i >= 0; i--) {
                        if (nodes[i].isPointInside(x, y)) {
                            createEdge(edgeStartNode, nodes[i]);
                            break;
                        }
                    }
                    
                    connectingNodes = false;
                    edgeStartNode = null;
                    drawGraph();
                }
                
                isDragging = false;
                if (mode === 'deleteEdge') {
                    setMode('select');
                }
            });

            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                connectingNodes = false;
                edgeStartNode = null;
                if (mode === 'deleteEdge') {
                    setMode('select');
                }
            });

            // Ocultar men√∫s contextuales al hacer clic en cualquier lugar
            document.addEventListener('click', hideContextMenus);
            
            // Validar que el peso de la arista sea positivo
            edgeWeightInput.addEventListener('change', function() {
                let weight = parseInt(this.value);
                if (isNaN(weight) || weight < 1) {
                    alert('El peso debe ser un n√∫mero positivo mayor que 0.');
                    this.value = '1';
                }
            });
        });
    </script>
</body>
</html>