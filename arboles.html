<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de √Årboles Binarios</title>
    <style>
        :root {
            --primary: #667eea;
            --primary-dark: #5a6fd8;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --background: #1e293b;
            --surface: #334155;
            --text: #f8fafc;
            --text-secondary: #cbd5e1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a, #1e293b);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--surface);
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            padding: 24px 32px;
            text-align: center;
            border-radius: 16px 16px 0 0;
            position: relative;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 24px;
            padding: 24px;
            min-height: 700px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            font-size: 1.3rem;
            margin-bottom: 16px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 4px;
        }

        .tab {
            flex: 1;
            padding: 10px 16px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            text-align: center;
        }

        .tab.active {
            background: var(--primary);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .input-group {
            margin-bottom: 16px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 12px 16px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 12px;
        }

        .btn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .btn-success {
            background: var(--success);
        }

        .btn-warning {
            background: var(--warning);
        }

        .btn-danger {
            background: var(--error);
        }

        .visualization-area {
            background: linear-gradient(135deg, #0f172a, #1e1e2e);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        #treeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .tree-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .info-card .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 4px;
        }

        .info-card .label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .results {
            margin-top: 20px;
        }

        .result-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
            border-left: 4px solid var(--primary);
        }

        .result-item h4 {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .result-item p {
            word-break: break-all;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 4px;
        }

        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-success {
            background: rgba(16, 185, 129, 0.2);
            border-left: 4px solid var(--success);
        }

        .alert-error {
            background: rgba(239, 68, 68, 0.2);
            border-left: 4px solid var(--error);
        }

        .alert-warning {
            background: rgba(245, 158, 11, 0.2);
            border-left: 4px solid var(--warning);
        }

        .file-upload {
            display: none;
        }

        .file-label {
            display: block;
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            margin-bottom: 12px;
        }

        .file-label:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--primary);
        }

        .examples {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
        }

        .empty-state h3 {
            margin-bottom: 8px;
            font-size: 1.5rem;
        }

        .empty-state p {
            max-width: 300px;
            margin: 0 auto;
        }

        .redirect-btn {
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
            margin: 0 5px;
        }

        .redirect-btn:hover {
            background: #45a049;
        }

        .help-btn {
            background: var(--warning);
        }

        .help-btn:hover {
            background: #e69500;
        }

        /* Modal de ayuda */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--surface);
            border-radius: 12px;
            padding: 24px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--text);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            margin-bottom: 10px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .help-section p {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .help-section ul {
            margin-left: 20px;
            margin-bottom: 10px;
        }

        .help-section li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .manual-insertion-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .manual-insertion-controls input {
            grid-column: 1 / -1;
        }

        .manual-insertion-controls button {
            margin-bottom: 0;
        }

        .node-history {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            max-height: 150px;
            overflow-y: auto;
        }

        .node-history h4 {
            margin-bottom: 8px;
            font-size: 1rem;
            color: var(--text-secondary);
        }

        .node-history-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .node-history-item {
            background: var(--primary);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 300px 1fr;
            }
            
            .right-panel {
                grid-column: 1 / -1;
                margin-top: 20px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tree-info {
                grid-template-columns: 1fr;
            }
            
            .examples {
                grid-template-columns: 1fr;
            }
            
            .manual-insertion-controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≥ Visualizador de √Årboles Binarios</h1>
            <p>Construye, visualiza y analiza √°rboles binarios de forma interactiva</p>
            
            <div>
                <button onclick="window.location.href='grafos johnson.html'" class="redirect-btn">
                    üå≥ Ir a Grafos
                </button>
                <button id="helpBtn" class="redirect-btn help-btn">
                    ‚ùì Ayuda
                </button>
            </div>
        </div>
        
        <div class="main-content">
            <!-- Panel izquierdo: Controles -->
            <div class="panel left-panel">
                <h2 class="panel-title">‚öôÔ∏è Controles</h2>
                
                <!-- Tabs para cambiar entre modos -->
                <div class="tabs">
                    <button class="tab active" data-tab="array">Array</button>
                    <button class="tab" data-tab="traversals">Recorridos</button>
                    <button class="tab" data-tab="manual">Manual</button>
                </div>
                
                <!-- Modo Array -->
                <div class="tab-content active" id="arrayTab">
                    <div class="alert alert-warning">
                        <span>‚ö†Ô∏è</span>
                        <div>Se crear√°n √Årboles Binarios de B√∫squeda (BST) balanceados autom√°ticamente</div>
                    </div>
                    
                    <div class="input-group">
                        <label for="arrayInput">Introduce n√∫meros o letras separados por comas:</label>
                        <input type="text" id="arrayInput" placeholder="Ej: 5,3,7,1,9,2,8 o A,C,B,E,D">
                    </div>
                    
                    <div class="input-group">
                        <label for="arrayType">Tipo de datos:</label>
                        <select id="arrayType">
                            <option value="numbers">N√∫meros</option>
                            <option value="letters">Letras</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-success" id="buildFromArrayBtn">
                        üå≥ Crear √Årbol Binario
                    </button>
                </div>
                
                <!-- Modo Recorridos -->
                <div class="tab-content" id="traversalsTab">
                    <div class="alert alert-warning">
                        <span>‚ÑπÔ∏è</span>
                        <div>INORDEN es obligatorio + PREORDEN o POSTORDEN</div>
                    </div>
                    
                    <div class="input-group">
                        <label for="preorderInput">Preorden (Ra√≠z-Izq-Der):</label>
                        <input type="text" id="preorderInput" placeholder="Ej: A,B,D,E,C,F">
                    </div>
                    
                    <div class="input-group">
                        <label for="inorderInput">Inorden (Izq-Ra√≠z-Der) *OBLIGATORIO:</label>
                        <input type="text" id="inorderInput" placeholder="Ej: D,B,E,A,F,C">
                    </div>
                    
                    <div class="input-group">
                        <label for="postorderInput">Postorden (Izq-Der-Ra√≠z):</label>
                        <input type="text" id="postorderInput" placeholder="Ej: D,E,B,F,C,A">
                    </div>
                    
                    <button class="btn" id="reconstructTreeBtn">
                        üîÑ Reconstruir desde Preorden+Inorden
                    </button>
                    
                    <button class="btn btn-secondary" id="buildFromInorderPostorderBtn">
                        üîÑ Reconstruir desde Inorden+Postorden
                    </button>
                </div>
                
                <!-- Modo Manual -->
                <div class="tab-content" id="manualTab">
                    <div class="alert alert-warning">
                        <span>‚ö†Ô∏è</span>
                        <div>Inserta nodos uno por uno para construir un √Årbol Binario de B√∫squeda (BST)</div>
                    </div>
                    
                    <div class="input-group">
                        <label for="manualNodeValue">Valor del nodo:</label>
                        <input type="text" id="manualNodeValue" placeholder="Ej: 5 o A">
                    </div>
                    
                    <div class="input-group">
                        <label for="manualType">Tipo de datos:</label>
                        <select id="manualType">
                            <option value="numbers">N√∫meros</option>
                            <option value="letters">Letras</option>
                        </select>
                    </div>
                    
                    <div class="manual-insertion-controls">
                        <button class="btn btn-success" id="insertNodeBtn">
                            ‚ûï Insertar Nodo
                        </button>
                        <button class="btn btn-danger" id="removeNodeBtn">
                            ‚ûñ Eliminar Nodo
                        </button>
                    </div>
                    
                    <div class="node-history">
                        <h4>Historial de nodos insertados:</h4>
                        <div class="node-history-list" id="nodeHistoryList">
                            <!-- Los nodos se mostrar√°n aqu√≠ -->
                        </div>
                    </div>
                    
                    <button class="btn btn-secondary" id="clearManualTreeBtn">
                        üóëÔ∏è Limpiar √Årbol Manual
                    </button>
                </div>
                
                <!-- Recorridos -->
                <div class="input-group">
                    <h3 class="panel-title">üìä Recorridos</h3>
                    <button class="btn btn-secondary" id="showPreorderBtn">
                        üìã Preorden
                    </button>
                    <button class="btn btn-secondary" id="showInorderBtn">
                        üìä Inorden
                    </button>
                    <button class="btn btn-secondary" id="showPostorderBtn">
                        üìù Postorden
                    </button>
                </div>
                
                <!-- Gesti√≥n de archivos -->
                <div class="input-group">
                    <h3 class="panel-title">üíæ Gesti√≥n de Archivos</h3>
                    <button class="btn btn-success" id="exportTreeBtn">
                        üíæ Exportar √Årbol
                    </button>
                    <input type="file" id="importTreeFile" class="file-upload" accept=".json">
                    <label for="importTreeFile" class="file-label">
                        üìÇ Importar √Årbol
                    </label>
                    <button class="btn btn-danger" id="clearTreeBtn">
                        üóëÔ∏è Limpiar Todo
                    </button>
                </div>
                
                <!-- Ejemplos -->
                <div class="input-group">
                    <h3 class="panel-title">üí° Ejemplos</h3>
                    <div class="examples">
                        <button class="btn btn-secondary" id="exampleArrayNumbersBtn">
                            üî¢ N√∫meros
                        </button>
                        <button class="btn btn-secondary" id="exampleArrayLettersBtn">
                            üî§ Letras
                        </button>
                        <button class="btn btn-secondary" id="exampleTraversalsBtn">
                            üîÑ Recorridos
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Panel central: Visualizaci√≥n -->
            <div class="panel visualization-area">
                <canvas id="treeCanvas"></canvas>
                <div class="empty-state" id="emptyState">
                    <h3>üå≥ √Årbol Vac√≠o</h3>
                    <p>Usa los controles del panel izquierdo para crear tu primer √°rbol binario</p>
                </div>
            </div>
            
            <!-- Panel derecho: Informaci√≥n y resultados -->
            <div class="panel right-panel">
                <h2 class="panel-title">üìä Informaci√≥n</h2>
                
                <div class="tree-info">
                    <div class="info-card">
                        <div class="value" id="nodeCount">0</div>
                        <div class="label">Nodos</div>
                    </div>
                    <div class="info-card">
                        <div class="value" id="treeHeight">0</div>
                        <div class="label">Altura</div>
                    </div>
                    <div class="info-card">
                        <div class="value" id="treeLevels">0</div>
                        <div class="label">Niveles</div>
                    </div>
                    <div class="info-card">
                        <div class="value" id="treeBalanced">No</div>
                        <div class="label">Balanceado</div>
                    </div>
                </div>
                
                <div class="results" id="resultsContainer">
                    <div class="alert alert-success">
                        <span>‚úÖ</span>
                        <div>Listo para crear √°rboles binarios</div>
                    </div>
                </div>
                
                <div class="result-item" id="preorderResult" style="display: none;">
                    <h4>üìã Preorden</h4>
                    <p id="preorderText"></p>
                </div>
                
                <div class="result-item" id="inorderResult" style="display: none;">
                    <h4>üìä Inorden</h4>
                    <p id="inorderText"></p>
                </div>
                
                <div class="result-item" id="postorderResult" style="display: none;">
                    <h4>üìù Postorden</h4>
                    <p id="postorderText"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de ayuda -->
    <div class="modal" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìñ Gu√≠a de Uso</h2>
                <button class="close-modal" id="closeHelpModal">‚úï</button>
            </div>
            
            <div class="help-section">
                <h3>üå≥ Crear √Årbol desde Array</h3>
                <p>Introduce n√∫meros o letras separados por comas. El sistema crear√° un BST balanceado autom√°ticamente.</p>
                <ul>
                    <li>Ejemplo de n√∫meros: <code>5,3,7,1,9,2,8</code></li>
                    <li>Ejemplo de letras: <code>A,C,B,E,D</code></li>
                </ul>
            </div>
            
            <div class="help-section">
                <h3>üîÑ Reconstruir desde Recorridos</h3>
                <p>Proporciona los recorridos INORDEN y PREORDEN o POSTORDEN para reconstruir el √°rbol.</p>
                <ul>
                    <li>INORDEN es obligatorio</li>
                    <li>Debes proporcionar PREORDEN O POSTORDEN (no ambos)</li>
                    <li>Ejemplo: Preorden: <code>A,B,D,E,C,F</code>, Inorden: <code>D,B,E,A,F,C</code></li>
                </ul>
            </div>
            
            <div class="help-section">
                <h3>‚ûï Inserci√≥n Manual</h3>
                <p>Inserta nodos uno por uno para construir un √Årbol Binario de B√∫squeda.</p>
                <ul>
                    <li>Introduce el valor del nodo y selecciona el tipo de datos</li>
                    <li>Haz clic en "Insertar Nodo" para a√±adirlo al √°rbol</li>
                    <li>Puedes eliminar nodos espec√≠ficos con "Eliminar Nodo"</li>
                    <li>El historial muestra los nodos que has insertado</li>
                </ul>
            </div>
            
            <div class="help-section">
                <h3>üìä Recorridos</h3>
                <p>Muestra los diferentes recorridos del √°rbol actual:</p>
                <ul>
                    <li><strong>Preorden:</strong> Ra√≠z - Izquierda - Derecha</li>
                    <li><strong>Inorden:</strong> Izquierda - Ra√≠z - Derecha (ordenado en BST)</li>
                    <li><strong>Postorden:</strong> Izquierda - Derecha - Ra√≠z</li>
                </ul>
            </div>
            
            <div class="help-section">
                <h3>üíæ Gesti√≥n de Archivos</h3>
                <p>Guarda y carga tus √°rboles:</p>
                <ul>
                    <li><strong>Exportar:</strong> Guarda el √°rbol actual en un archivo JSON</li>
                    <li><strong>Importar:</strong> Carga un √°rbol desde un archivo JSON previamente exportado</li>
                    <li><strong>Limpiar Todo:</strong> Elimina el √°rbol actual</li>
                </ul>
            </div>
            
            <div class="help-section">
                <h3>üí° Ejemplos</h3>
                <p>Utiliza los ejemplos predefinidos para probar la herramienta r√°pidamente.</p>
            </div>
            
            <div class="help-section">
                <h3>‚ÑπÔ∏è Informaci√≥n del √Årbol</h3>
                <p>El panel derecho muestra informaci√≥n √∫til sobre el √°rbol:</p>
                <ul>
                    <li><strong>Nodos:</strong> Cantidad total de nodos en el √°rbol</li>
                    <li><strong>Altura:</strong> Longitud del camino m√°s largo desde la ra√≠z a una hoja</li>
                    <li><strong>Niveles:</strong> N√∫mero de niveles en el √°rbol (igual a la altura)</li>
                    <li><strong>Balanceado:</strong> Indica si el √°rbol est√° balanceado (diferencia de altura entre sub√°rboles ‚â§ 1)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // CLASE TREE NODE
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
                this.level = 0;
            }
        }

        // CLASE TREE VISUALIZER
        class TreeVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.root = null;
                this.nodeRadius = 30;
                this.levelHeight = 100;
                this.treeType = "Ninguno";
                this.nodeHistory = []; // Para el modo manual
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.drawTree();
            }

            // M√âTODO PARA CREAR BST DESDE ARRAY
            buildBSTFromArray(array, isNumbers = true) {
                if (array.length === 0) return null;
                
                // Ordenar el array para crear un BST balanceado
                let sortedArray;
                if (isNumbers) {
                    sortedArray = [...array].sort((a, b) => a - b);
                } else {
                    sortedArray = [...array].sort();
                }
                
                return this._buildBalancedBST(sortedArray, 0, sortedArray.length - 1);
            }

            _buildBalancedBST(array, start, end) {
                if (start > end) return null;
                
                const mid = Math.floor((start + end) / 2);
                const node = new TreeNode(array[mid]);
                
                node.left = this._buildBalancedBST(array, start, mid - 1);
                node.right = this._buildBalancedBST(array, mid + 1, end);
                
                return node;
            }

            // M√âTODOS PARA INSERCI√ìN MANUAL
            insertNode(value, isNumbers = true) {
                if (!this.root) {
                    this.root = new TreeNode(value);
                    this.nodeHistory.push(value);
                    return;
                }
                
                this._insertNode(this.root, value, isNumbers);
                this.nodeHistory.push(value);
            }

            _insertNode(node, value, isNumbers) {
                if (isNumbers) {
                    if (value < node.value) {
                        if (node.left === null) {
                            node.left = new TreeNode(value);
                        } else {
                            this._insertNode(node.left, value, isNumbers);
                        }
                    } else if (value > node.value) {
                        if (node.right === null) {
                            node.right = new TreeNode(value);
                        } else {
                            this._insertNode(node.right, value, isNumbers);
                        }
                    }
                } else {
                    // Para letras, comparamos como strings
                    if (value < node.value) {
                        if (node.left === null) {
                            node.left = new TreeNode(value);
                        } else {
                            this._insertNode(node.left, value, isNumbers);
                        }
                    } else if (value > node.value) {
                        if (node.right === null) {
                            node.right = new TreeNode(value);
                        } else {
                            this._insertNode(node.right, value, isNumbers);
                        }
                    }
                }
            }

            // M√âTODO PARA ELIMINAR NODO
            removeNode(value, isNumbers = true) {
                this.root = this._removeNode(this.root, value, isNumbers);
                const index = this.nodeHistory.indexOf(value);
                if (index !== -1) {
                    this.nodeHistory.splice(index, 1);
                }
            }

            _removeNode(node, value, isNumbers) {
                if (node === null) return null;
                
                if (isNumbers) {
                    if (value < node.value) {
                        node.left = this._removeNode(node.left, value, isNumbers);
                    } else if (value > node.value) {
                        node.right = this._removeNode(node.right, value, isNumbers);
                    } else {
                        // Nodo encontrado
                        if (node.left === null && node.right === null) {
                            return null;
                        } else if (node.left === null) {
                            return node.right;
                        } else if (node.right === null) {
                            return node.left;
                        } else {
                            // Nodo con dos hijos
                            const minRight = this._findMinNode(node.right);
                            node.value = minRight.value;
                            node.right = this._removeNode(node.right, minRight.value, isNumbers);
                        }
                    }
                } else {
                    // Para letras
                    if (value < node.value) {
                        node.left = this._removeNode(node.left, value, isNumbers);
                    } else if (value > node.value) {
                        node.right = this._removeNode(node.right, value, isNumbers);
                    } else {
                        // Nodo encontrado
                        if (node.left === null && node.right === null) {
                            return null;
                        } else if (node.left === null) {
                            return node.right;
                        } else if (node.right === null) {
                            return node.left;
                        } else {
                            // Nodo con dos hijos
                            const minRight = this._findMinNode(node.right);
                            node.value = minRight.value;
                            node.right = this._removeNode(node.right, minRight.value, isNumbers);
                        }
                    }
                }
                
                return node;
            }

            _findMinNode(node) {
                while (node.left !== null) {
                    node = node.left;
                }
                return node;
            }

            // M√âTODOS PARA RECONSTRUCCI√ìN DESDE RECORRIDOS
            buildFromPreorderInorder(preorder, inorder) {
                if (preorder.length === 0 || inorder.length === 0) return null;
                if (preorder.length !== inorder.length) {
                    throw new Error("Los recorridos deben tener la misma longitud");
                }

                const rootVal = preorder[0];
                const root = new TreeNode(rootVal);
                const rootIndex = inorder.indexOf(rootVal);

                if (rootIndex === -1) {
                    throw new Error(`Elemento ${rootVal} no encontrado en inorden`);
                }

                const leftInorder = inorder.slice(0, rootIndex);
                const rightInorder = inorder.slice(rootIndex + 1);
                const leftPreorder = preorder.slice(1, 1 + leftInorder.length);
                const rightPreorder = preorder.slice(1 + leftInorder.length);

                root.left = this.buildFromPreorderInorder(leftPreorder, leftInorder);
                root.right = this.buildFromPreorderInorder(rightPreorder, rightInorder);

                return root;
            }

            buildFromInorderPostorder(inorder, postorder) {
                if (inorder.length === 0 || postorder.length === 0) return null;
                if (inorder.length !== postorder.length) {
                    throw new Error("Los recorridos deben tener la misma longitud");
                }

                const rootVal = postorder[postorder.length - 1];
                const root = new TreeNode(rootVal);
                const rootIndex = inorder.indexOf(rootVal);

                if (rootIndex === -1) {
                    throw new Error(`Elemento ${rootVal} no encontrado en inorden`);
                }

                const leftInorder = inorder.slice(0, rootIndex);
                const rightInorder = inorder.slice(rootIndex + 1);
                const leftPostorder = postorder.slice(0, leftInorder.length);
                const rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);

                root.left = this.buildFromInorderPostorder(leftInorder, leftPostorder);
                root.right = this.buildFromInorderPostorder(rightInorder, rightPostorder);

                return root;
            }

            calculateTreeInfo(node) {
                if (!node) return { height: 0, nodeCount: 0, balanced: true };
                
                const leftInfo = this.calculateTreeInfo(node.left);
                const rightInfo = this.calculateTreeInfo(node.right);
                
                const height = Math.max(leftInfo.height, rightInfo.height) + 1;
                const nodeCount = leftInfo.nodeCount + rightInfo.nodeCount + 1;
                const balanced = leftInfo.balanced && rightInfo.balanced && 
                                Math.abs(leftInfo.height - rightInfo.height) <= 1;
                
                return { height, nodeCount, balanced };
            }

            calculatePositions(node, level, minPos, maxPos) {
                if (!node) return;
                
                node.level = level;
                node.y = level * this.levelHeight + 80;
                node.x = (minPos + maxPos) / 2;

                if (node.left) {
                    this.calculatePositions(node.left, level + 1, minPos, node.x - 60);
                }
                if (node.right) {
                    this.calculatePositions(node.right, level + 1, node.x + 60, maxPos);
                }
            }

            drawTree() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.root) {
                    document.getElementById('emptyState').style.display = 'block';
                    return;
                }
                
                document.getElementById('emptyState').style.display = 'none';

                this.calculatePositions(this.root, 0, 60, this.canvas.width - 60);
                this.drawConnections(this.root);
                this.drawNode(this.root);
                
                // Actualizar informaci√≥n del √°rbol
                this.updateTreeInfo();
            }

            drawConnections(node) {
                if (!node) return;

                this.ctx.strokeStyle = '#667eea';
                this.ctx.lineWidth = 3;
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = '#667eea';

                if (node.left) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(node.x, node.y);
                    this.ctx.lineTo(node.left.x, node.left.y);
                    this.ctx.stroke();
                    this.drawConnections(node.left);
                }

                if (node.right) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(node.x, node.y);
                    this.ctx.lineTo(node.right.x, node.right.y);
                    this.ctx.stroke();
                    this.drawConnections(node.right);
                }

                this.ctx.shadowBlur = 0;
            }

            drawNode(node) {
                if (!node) return;

                // Gradiente para el nodo
                const gradient = this.ctx.createRadialGradient(
                    node.x, node.y, 0, node.x, node.y, this.nodeRadius
                );
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#5a6fd8');

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(node.x, node.y, this.nodeRadius, 0, 2 * Math.PI);
                this.ctx.fill();

                // Borde del nodo
                this.ctx.strokeStyle = '#5a6fd8';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                // Sombra del nodo
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = '#667eea';

                // Texto del nodo
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(node.value, node.x, node.y);

                this.ctx.shadowBlur = 0;

                // Recursi√≥n para hijos
                this.drawNode(node.left);
                this.drawNode(node.right);
            }

            updateTreeInfo() {
                if (!this.root) {
                    document.getElementById('nodeCount').textContent = '0';
                    document.getElementById('treeHeight').textContent = '0';
                    document.getElementById('treeLevels').textContent = '0';
                    document.getElementById('treeBalanced').textContent = 'No';
                    return;
                }

                const info = this.calculateTreeInfo(this.root);
                document.getElementById('nodeCount').textContent = info.nodeCount;
                document.getElementById('treeHeight').textContent = info.height;
                document.getElementById('treeLevels').textContent = info.height;
                document.getElementById('treeBalanced').textContent = info.balanced ? 'S√≠' : 'No';
            }

            // M√©todos de recorrido
            preorderTraversal(node, result = []) {
                if (!node) return result;
                result.push(node.value);
                this.preorderTraversal(node.left, result);
                this.preorderTraversal(node.right, result);
                return result;
            }

            inorderTraversal(node, result = []) {
                if (!node) return result;
                this.inorderTraversal(node.left, result);
                result.push(node.value);
                this.inorderTraversal(node.right, result);
                return result;
            }

            postorderTraversal(node, result = []) {
                if (!node) return result;
                this.postorderTraversal(node.left, result);
                this.postorderTraversal(node.right, result);
                result.push(node.value);
                return result;
            }

            // Exportar √°rbol a JSON
            exportToJSON() {
                if (!this.root) {
                    throw new Error("No hay √°rbol para exportar");
                }

                const treeData = {
                    preorder: this.preorderTraversal(this.root),
                    inorder: this.inorderTraversal(this.root),
                    postorder: this.postorderTraversal(this.root),
                    nodeCount: this.calculateTreeInfo(this.root).nodeCount,
                    treeType: this.treeType,
                    exportDate: new Date().toISOString()
                };

                return JSON.stringify(treeData, null, 2);
            }

            // Importar √°rbol desde JSON
            importFromJSON(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    
                    if (data.preorder && data.inorder) {
                        this.root = this.buildFromPreorderInorder(data.preorder, data.inorder);
                        this.treeType = data.treeType || "Desde Recorridos";
                        this.drawTree();
                        return true;
                    } else if (data.inorder && data.postorder) {
                        this.root = this.buildFromInorderPostorder(data.inorder, data.postorder);
                        this.treeType = data.treeType || "Desde Recorridos";
                        this.drawTree();
                        return true;
                    } else {
                        throw new Error("Formato JSON inv√°lido: faltan recorridos necesarios");
                    }
                } catch (error) {
                    throw new Error(`Error al importar: ${error.message}`);
                }
            }

            clear() {
                this.root = null;
                this.treeType = "Ninguno";
                this.nodeHistory = [];
                this.updateNodeHistory();
                this.drawTree();
            }

            // Actualizar el historial de nodos en la interfaz
            updateNodeHistory() {
                const nodeHistoryList = document.getElementById('nodeHistoryList');
                nodeHistoryList.innerHTML = '';
                
                this.nodeHistory.forEach(value => {
                    const nodeItem = document.createElement('div');
                    nodeItem.className = 'node-history-item';
                    nodeItem.textContent = value;
                    nodeHistoryList.appendChild(nodeItem);
                });
            }
        }

        // INICIALIZACI√ìN MEJORADA
        document.addEventListener('DOMContentLoaded', function() {
            const treeVisualizer = new TreeVisualizer('treeCanvas');
            
            // Tabs functionality
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs and contents
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab') + 'Tab';
                    document.getElementById(tabId).classList.add('active');
                });
            });

            // Construir desde Array
            document.getElementById('buildFromArrayBtn').addEventListener('click', () => {
                const arrayInput = document.getElementById('arrayInput').value;
                const arrayType = document.getElementById('arrayType').value;
                
                try {
                    let array;
                    if (arrayType === 'numbers') {
                        array = arrayInput.split(',').map(item => {
                            const num = parseFloat(item.trim());
                            if (isNaN(num)) throw new Error(`"${item}" no es un n√∫mero v√°lido`);
                            return num;
                        });
                    } else {
                        array = arrayInput.split(',').map(item => item.trim().toUpperCase());
                        if (array.some(item => item.length !== 1 || !item.match(/[A-Z]/))) {
                            throw new Error("Solo se permiten letras individuales de A-Z");
                        }
                    }

                    if (array.length === 0) {
                        throw new Error("El array no puede estar vac√≠o");
                    }

                    // Eliminar duplicados
                    const uniqueArray = [...new Set(array)];
                    if (uniqueArray.length !== array.length) {
                        showWarning(`Se eliminaron ${array.length - uniqueArray.length} elementos duplicados`);
                    }

                    treeVisualizer.root = treeVisualizer.buildBSTFromArray(uniqueArray, arrayType === 'numbers');
                    treeVisualizer.treeType = `BST desde Array (${arrayType === 'numbers' ? 'N√∫meros' : 'Letras'})`;
                    treeVisualizer.drawTree();
                    showSuccess(`√Årbol BST creado desde array con ${uniqueArray.length} elementos √∫nicos`);
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Reconstruir desde Preorden + Inorden
            document.getElementById('reconstructTreeBtn').addEventListener('click', () => {
                const preorder = document.getElementById('preorderInput').value.split(',').map(s => s.trim()).filter(s => s);
                const inorder = document.getElementById('inorderInput').value.split(',').map(s => s.trim()).filter(s => s);
                
                try {
                    validateTraversalInputs(preorder, inorder, []);
                    treeVisualizer.root = treeVisualizer.buildFromPreorderInorder(preorder, inorder);
                    treeVisualizer.treeType = "Desde Preorden+Inorden";
                    treeVisualizer.drawTree();
                    showSuccess('√Årbol reconstruido exitosamente desde Preorden + Inorden');
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Reconstruir desde Inorden + Postorden
            document.getElementById('buildFromInorderPostorderBtn').addEventListener('click', () => {
                const inorder = document.getElementById('inorderInput').value.split(',').map(s => s.trim()).filter(s => s);
                const postorder = document.getElementById('postorderInput').value.split(',').map(s => s.trim()).filter(s => s);
                
                try {
                    validateTraversalInputs([], inorder, postorder);
                    treeVisualizer.root = treeVisualizer.buildFromInorderPostorder(inorder, postorder);
                    treeVisualizer.treeType = "Desde Inorden+Postorden";
                    treeVisualizer.drawTree();
                    showSuccess('√Årbol reconstruido exitosamente desde Inorden + Postorden');
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Insertar nodo manualmente
            document.getElementById('insertNodeBtn').addEventListener('click', () => {
                const nodeValue = document.getElementById('manualNodeValue').value.trim();
                const manualType = document.getElementById('manualType').value;
                
                try {
                    if (!nodeValue) {
                        throw new Error("Por favor, introduce un valor para el nodo");
                    }

                    let value;
                    if (manualType === 'numbers') {
                        value = parseFloat(nodeValue);
                        if (isNaN(value)) {
                            throw new Error(`"${nodeValue}" no es un n√∫mero v√°lido`);
                        }
                    } else {
                        value = nodeValue.toUpperCase();
                        if (value.length !== 1 || !value.match(/[A-Z]/)) {
                            throw new Error("Solo se permiten letras individuales de A-Z");
                        }
                    }

                    treeVisualizer.insertNode(value, manualType === 'numbers');
                    treeVisualizer.treeType = `BST Manual (${manualType === 'numbers' ? 'N√∫meros' : 'Letras'})`;
                    treeVisualizer.drawTree();
                    treeVisualizer.updateNodeHistory();
                    showSuccess(`Nodo ${value} insertado correctamente`);
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Eliminar nodo manualmente
            document.getElementById('removeNodeBtn').addEventListener('click', () => {
                const nodeValue = document.getElementById('manualNodeValue').value.trim();
                const manualType = document.getElementById('manualType').value;
                
                try {
                    if (!nodeValue) {
                        throw new Error("Por favor, introduce un valor para eliminar el nodo");
                    }

                    let value;
                    if (manualType === 'numbers') {
                        value = parseFloat(nodeValue);
                        if (isNaN(value)) {
                            throw new Error(`"${nodeValue}" no es un n√∫mero v√°lido`);
                        }
                    } else {
                        value = nodeValue.toUpperCase();
                        if (value.length !== 1 || !value.match(/[A-Z]/)) {
                            throw new Error("Solo se permiten letras individuales de A-Z");
                        }
                    }

                    if (!treeVisualizer.root) {
                        throw new Error("No hay √°rbol para eliminar nodos");
                    }

                    treeVisualizer.removeNode(value, manualType === 'numbers');
                    treeVisualizer.treeType = `BST Manual (${manualType === 'numbers' ? 'N√∫meros' : 'Letras'})`;
                    treeVisualizer.drawTree();
                    treeVisualizer.updateNodeHistory();
                    showSuccess(`Nodo ${value} eliminado correctamente`);
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Limpiar √°rbol manual
            document.getElementById('clearManualTreeBtn').addEventListener('click', () => {
                treeVisualizer.clear();
                showSuccess('√Årbol manual limpiado');
                hideTraversalResults();
                hideResults();
            });

            // Botones de recorridos
            document.getElementById('showPreorderBtn').addEventListener('click', () => {
                if (!treeVisualizer.root) {
                    showError('No hay √°rbol para recorrer');
                    return;
                }
                const result = treeVisualizer.preorderTraversal(treeVisualizer.root);
                document.getElementById('preorderText').textContent = result.join(' ‚Üí ');
                document.getElementById('preorderResult').style.display = 'block';
            });

            document.getElementById('showInorderBtn').addEventListener('click', () => {
                if (!treeVisualizer.root) {
                    showError('No hay √°rbol para recorrer');
                    return;
                }
                const result = treeVisualizer.inorderTraversal(treeVisualizer.root);
                document.getElementById('inorderText').textContent = result.join(' ‚Üí ');
                document.getElementById('inorderResult').style.display = 'block';
            });

            document.getElementById('showPostorderBtn').addEventListener('click', () => {
                if (!treeVisualizer.root) {
                    showError('No hay √°rbol para recorrer');
                    return;
                }
                const result = treeVisualizer.postorderTraversal(treeVisualizer.root);
                document.getElementById('postorderText').textContent = result.join(' ‚Üí ');
                document.getElementById('postorderResult').style.display = 'block';
            });

            // Exportar √°rbol
            document.getElementById('exportTreeBtn').addEventListener('click', () => {
                try {
                    const jsonData = treeVisualizer.exportToJSON();
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `arbol_binario_${new Date().getTime()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showSuccess('√Årbol exportado exitosamente');
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Importar √°rbol
            document.getElementById('importTreeFile').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        treeVisualizer.importFromJSON(e.target.result);
                        showSuccess('√Årbol importado exitosamente');
                        updateTraversalResults(treeVisualizer);
                    } catch (error) {
                        showError(`${error.message}`);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset input
            });

            // Limpiar √°rbol
            document.getElementById('clearTreeBtn').addEventListener('click', () => {
                treeVisualizer.clear();
                showSuccess('√Årbol limpiado');
                hideTraversalResults();
                hideResults();
            });

            // Ejemplos
            document.getElementById('exampleArrayNumbersBtn').addEventListener('click', () => {
                document.getElementById('arrayInput').value = '5,3,7,1,9,2,8,4,6';
                document.getElementById('arrayType').value = 'numbers';
                showSuccess('Ejemplo de n√∫meros cargado. Haz clic en "Crear √Årbol Binario"');
            });

            document.getElementById('exampleArrayLettersBtn').addEventListener('click', () => {
                document.getElementById('arrayInput').value = 'D,B,F,A,C,E,G';
                document.getElementById('arrayType').value = 'letters';
                showSuccess('Ejemplo de letras cargado. Haz clic en "Crear √Årbol Binario"');
            });

            document.getElementById('exampleTraversalsBtn').addEventListener('click', () => {
                document.getElementById('preorderInput').value = 'A,B,D,E,C,F';
                document.getElementById('inorderInput').value = 'D,B,E,A,F,C';
                document.getElementById('postorderInput').value = 'D,E,B,F,C,A';
                showSuccess('Ejemplo de recorridos cargado. Haz clic en "Reconstruir √Årbol"');
            });

            // Modal de ayuda
            document.getElementById('helpBtn').addEventListener('click', () => {
                document.getElementById('helpModal').style.display = 'flex';
            });

            document.getElementById('closeHelpModal').addEventListener('click', () => {
                document.getElementById('helpModal').style.display = 'none';
            });

            // Cerrar modal al hacer clic fuera
            window.addEventListener('click', (e) => {
                if (e.target === document.getElementById('helpModal')) {
                    document.getElementById('helpModal').style.display = 'none';
                }
            });

            // Funciones auxiliares
            function validateTraversalInputs(preorder, inorder, postorder) {
                if (inorder.length === 0) {
                    throw new Error("El recorrido INORDEN es obligatorio");
                }

                const hasPreorder = preorder.length > 0;
                const hasPostorder = postorder.length > 0;

                if (!hasPreorder && !hasPostorder) {
                    throw new Error("Debe proporcionar Preorden O Postorden junto con Inorden");
                }

                if (hasPreorder && hasPostorder) {
                    throw new Error("Solo debe proporcionar Preorden O Postorden, no ambos");
                }

                if (hasPreorder && preorder.length !== inorder.length) {
                    throw new Error("Preorden e Inorden deben tener la misma longitud");
                }

                if (hasPostorder && postorder.length !== inorder.length) {
                    throw new Error("Postorden e Inorden deben tener la misma longitud");
                }

                // Validar elementos √∫nicos y mismos conjuntos
                const inorderSet = new Set(inorder);
                const comparisonSet = hasPreorder ? new Set(preorder) : new Set(postorder);

                if (inorderSet.size !== inorder.length) {
                    throw new Error("El recorrido Inorden no puede tener elementos duplicados");
                }

                if (comparisonSet.size !== (hasPreorder ? preorder.length : postorder.length)) {
                    throw new Error("El otro recorrido no puede tener elementos duplicados");
                }

                if (inorderSet.size !== comparisonSet.size || ![...inorderSet].every(item => comparisonSet.has(item))) {
                    throw new Error("Los recorridos deben contener los mismos elementos");
                }
            }

            function showError(message) {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-error fade-in">
                        <span>‚ùå</span>
                        <div>${message}</div>
                    </div>
                `;
            }

            function showSuccess(message) {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-success fade-in">
                        <span>‚úÖ</span>
                        <div>${message}</div>
                    </div>
                `;
            }

            function showWarning(message) {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-warning fade-in">
                        <span>‚ö†Ô∏è</span>
                        <div>${message}</div>
                    </div>
                `;
            }

            function hideResults() {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-success">
                        <span>‚úÖ</span>
                        <div>Listo para crear √°rboles binarios</div>
                    </div>
                `;
            }

            function updateTraversalResults(tree) {
                const preorder = tree.preorderTraversal(tree.root);
                const inorder = tree.inorderTraversal(tree.root);
                const postorder = tree.postorderTraversal(tree.root);
                
                document.getElementById('preorderText').textContent = preorder.join(' ‚Üí ');
                document.getElementById('inorderText').textContent = inorder.join(' ‚Üí ');
                document.getElementById('postorderText').textContent = postorder.join(' ‚Üí ');
                
                document.getElementById('preorderResult').style.display = 'block';
                document.getElementById('inorderResult').style.display = 'block';
                document.getElementById('postorderResult').style.display = 'block';
            }

            function hideTraversalResults() {
                document.getElementById('preorderResult').style.display = 'none';
                document.getElementById('inorderResult').style.display = 'none';
                document.getElementById('postorderResult').style.display = 'none';
            }
        });
    </script>
</body>
</html>
