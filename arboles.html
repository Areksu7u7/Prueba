<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de √Årboles Binarios | TRON</title>
    <style>
        :root {
            --primary: #00f7ff;
            --primary-dark: #00c4cc;
            --secondary: #ff00e6;
            --accent: #7f00ff;
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff0055;
            --background: #0a0a0f;
            --surface: #1a1a2e;
            --text: #e0e0ff;
            --text-secondary: #a0a0cc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        /* Efectos de grid estilo TRON */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(rgba(10, 10, 15, 0.9) 1px, transparent 1px),
                linear-gradient(90deg, rgba(10, 10, 15, 0.9) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            opacity: 0.3;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(26, 26, 46, 0.8);
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid var(--primary);
            box-shadow: 
                0 0 20px rgba(0, 247, 255, 0.3),
                inset 0 0 20px rgba(0, 247, 255, 0.1);
            position: relative;
        }

        .container::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
            animation: scanline 3s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(100vh); }
        }

        .header {
            background: linear-gradient(135deg, rgba(0, 247, 255, 0.1), rgba(127, 0, 255, 0.1));
            padding: 24px 32px;
            text-align: center;
            position: relative;
            border-bottom: 1px solid var(--primary);
            box-shadow: 0 0 15px rgba(0, 247, 255, 0.3);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            text-shadow: 0 0 10px var(--primary);
            letter-spacing: 2px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            text-shadow: 0 0 5px var(--primary);
        }

        .help-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 247, 255, 0.2);
            border: 1px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: var(--primary);
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.5);
        }

        .help-btn:hover {
            background: rgba(0, 247, 255, 0.3);
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--primary);
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 24px;
            padding: 24px;
            min-height: 700px;
        }

        .panel {
            background: rgba(10, 10, 15, 0.7);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--primary);
            box-shadow: 
                0 0 15px rgba(0, 247, 255, 0.2),
                inset 0 0 15px rgba(0, 247, 255, 0.1);
            position: relative;
        }

        .panel::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 1px solid transparent;
            border-radius: 12px;
            background: linear-gradient(45deg, var(--primary), var(--accent), var(--secondary), var(--primary));
            background-size: 400% 400%;
            z-index: -1;
            animation: gradientShift 8s ease infinite;
            opacity: 0.5;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .panel-title {
            font-size: 1.3rem;
            margin-bottom: 16px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0, 247, 255, 0.3);
            text-shadow: 0 0 5px var(--primary);
        }

        .panel-title .info-icon {
            cursor: help;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .panel-title .info-icon:hover {
            opacity: 1;
            text-shadow: 0 0 8px var(--primary);
        }

        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 4px;
            border: 1px solid rgba(0, 247, 255, 0.3);
        }

        .tab {
            flex: 1;
            padding: 10px 16px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            text-align: center;
        }

        .tab.active {
            background: var(--primary);
            color: var(--background);
            box-shadow: 0 0 10px var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .input-group {
            margin-bottom: 16px;
            position: relative;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--primary);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(0, 247, 255, 0.2);
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 10px var(--primary);
        }

        .btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 12px 16px;
            background: var(--primary);
            color: var(--background);
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 12px;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 10px rgba(0, 247, 255, 0.5);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px var(--primary);
        }

        .btn-secondary {
            background: rgba(0, 247, 255, 0.1);
            color: var(--primary);
            border: 1px solid var(--primary);
        }

        .btn-secondary:hover {
            background: rgba(0, 247, 255, 0.2);
        }

        .btn-success {
            background: var(--success);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .btn-success:hover {
            box-shadow: 0 0 15px var(--success);
        }

        .btn-warning {
            background: var(--warning);
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
        }

        .btn-warning:hover {
            box-shadow: 0 0 15px var(--warning);
        }

        .btn-danger {
            background: var(--error);
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.5);
        }

        .btn-danger:hover {
            box-shadow: 0 0 15px var(--error);
        }

        .visualization-area {
            background: rgba(10, 10, 15, 0.7);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--primary);
            box-shadow: 
                inset 0 0 20px rgba(0, 247, 255, 0.2),
                0 0 20px rgba(0, 247, 255, 0.2);
        }

        #treeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .tree-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 16px;
        }

        .info-card {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--primary);
            box-shadow: 0 0 8px rgba(0, 247, 255, 0.3);
        }

        .info-card .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 4px;
            text-shadow: 0 0 5px var(--primary);
        }

        .info-card .label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .results {
            margin-top: 20px;
        }

        .result-item {
            background: rgba(0, 0, 0, 0.4);
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
            border-left: 4px solid var(--primary);
            box-shadow: 0 0 8px rgba(0, 247, 255, 0.2);
        }

        .result-item h4 {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--primary);
        }

        .result-item p {
            word-break: break-all;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid rgba(0, 247, 255, 0.3);
        }

        .alert {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid;
            box-shadow: 0 0 8px rgba(0, 247, 255, 0.2);
        }

        .alert-success {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--success);
            color: var(--success);
        }

        .alert-error {
            background: rgba(255, 0, 85, 0.1);
            border-color: var(--error);
            color: var(--error);
        }

        .alert-warning {
            background: rgba(255, 170, 0, 0.1);
            border-color: var(--warning);
            color: var(--warning);
        }

        .file-upload {
            display: none;
        }

        .file-label {
            display: block;
            background: rgba(0, 247, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px dashed var(--primary);
            margin-bottom: 12px;
            color: var(--primary);
        }

        .file-label:hover {
            background: rgba(0, 247, 255, 0.2);
            box-shadow: 0 0 10px var(--primary);
        }

        .examples {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        .empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
        }

        .empty-state h3 {
            margin-bottom: 8px;
            font-size: 1.5rem;
            color: var(--primary);
            text-shadow: 0 0 5px var(--primary);
        }

        .empty-state p {
            max-width: 300px;
            margin: 0 auto;
        }

        /* Nuevos estilos para funcionalidades agregadas */
        .node-operations {
            margin-top: 20px;
        }

        .node-search {
            margin-bottom: 16px;
        }

        .highlighted {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 10px var(--primary); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px var(--primary); }
            100% { transform: scale(1); box-shadow: 0 0 10px var(--primary); }
        }

        .node-found {
            background: radial-gradient(circle, var(--success), #0d8b5c) !important;
        }

        .node-path {
            stroke: var(--success) !important;
            stroke-width: 4px !important;
        }

        .traversal-animation {
            transition: all 0.5s ease;
        }

        .traversal-active {
            background: radial-gradient(circle, var(--warning), #d97706) !important;
        }

        /* Mejoras para la secci√≥n de recorridos */
        .reconstruction-method {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .method-btn {
            flex: 1;
            padding: 10px;
            background: rgba(0, 247, 255, 0.1);
            border: 1px solid var(--primary);
            border-radius: 8px;
            color: var(--text);
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .method-btn.active {
            background: var(--primary);
            color: var(--background);
            box-shadow: 0 0 10px var(--primary);
        }

        .method-btn:hover:not(.active) {
            background: rgba(0, 247, 255, 0.2);
        }

        .traversal-inputs {
            display: none;
        }

        .traversal-inputs.active {
            display: block;
        }

        .traversal-explanation {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 3px solid var(--primary);
            font-size: 0.9rem;
        }

        .traversal-explanation h4 {
            color: var(--primary);
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Modal de ayuda */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--surface);
            border-radius: 16px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid var(--primary);
            box-shadow: 0 0 30px var(--primary);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 24px;
            border-bottom: 1px solid var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 247, 255, 0.1);
        }

        .modal-header h2 {
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
            text-shadow: 0 0 5px var(--primary);
        }

        .close-modal {
            background: none;
            border: none;
            color: var(--primary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .close-modal:hover {
            background: rgba(0, 247, 255, 0.2);
        }

        .modal-body {
            padding: 24px;
        }

        .help-section {
            margin-bottom: 30px;
        }

        .help-section h3 {
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
            text-shadow: 0 0 5px var(--primary);
        }

        .help-section p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .help-section ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }

        .help-section li {
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .help-section code {
            background: rgba(0, 0, 0, 0.5);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid var(--primary);
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: var(--background);
            color: var(--text);
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--primary);
            box-shadow: 0 0 15px var(--primary);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 300px 1fr;
            }
            
            .right-panel {
                grid-column: 1 / -1;
                margin-top: 20px;
            }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .tree-info {
                grid-template-columns: 1fr;
            }
            
            .examples {
                grid-template-columns: 1fr;
            }
            
            .reconstruction-method {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≥ VISUALIZADOR TRON | √ÅRBOLES BINARIOS</h1>
            <p>Construye, visualiza y analiza √°rboles binarios de forma interactiva</p>
            <button class="help-btn" id="helpBtn">?</button>
        </div>
        
        <div class="main-content">
            <!-- Panel izquierdo: Controles -->
            <div class="panel left-panel">
                <h2 class="panel-title">
                    ‚öôÔ∏è CONTROLES
                    <span class="info-icon tooltip">‚ÑπÔ∏è
                        <span class="tooltiptext">Desde aqu√≠ puedes crear y modificar √°rboles binarios usando diferentes m√©todos</span>
                    </span>
                </h2>
                
                <!-- Tabs para cambiar entre modos -->
                <div class="tabs">
                    <button class="tab active" data-tab="array">Array</button>
                    <button class="tab" data-tab="traversals">Recorridos</button>
                    <button class="tab" data-tab="operations">Operaciones</button>
                </div>
                
                <!-- Modo Array -->
                <div class="tab-content active" id="arrayTab">
                    <div class="alert alert-warning">
                        <span>‚ö†Ô∏è</span>
                        <div>Se crear√°n √Årboles Binarios de B√∫squeda (BST) balanceados autom√°ticamente</div>
                    </div>
                    
                    <div class="input-group">
                        <label for="arrayInput">Introduce n√∫meros o letras separados por comas:</label>
                        <input type="text" id="arrayInput" placeholder="Ej: 5,3,7,1,9,2,8 o A,C,B,E,D">
                    </div>
                    
                    <div class="input-group">
                        <label for="arrayType">Tipo de datos:</label>
                        <select id="arrayType">
                            <option value="numbers">N√∫meros</option>
                            <option value="letters">Letras</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-success" id="buildFromArrayBtn">
                        üå≥ CREAR √ÅRBOL BINARIO
                    </button>
                </div>
                
                <!-- Modo Recorridos - MEJORADO -->
                <div class="tab-content" id="traversalsTab">
                    <div class="alert alert-warning">
                        <span>‚ÑπÔ∏è</span>
                        <div>Selecciona un m√©todo de reconstrucci√≥n y proporciona los recorridos necesarios</div>
                    </div>
                    
                    <!-- Selector de m√©todo de reconstrucci√≥n -->
                    <div class="reconstruction-method">
                        <div class="method-btn active" data-method="preorder-inorder">
                            Preorden + Inorden
                        </div>
                        <div class="method-btn" data-method="inorder-postorder">
                            Inorden + Postorden
                        </div>
                    </div>
                    
                    <!-- Explicaci√≥n del m√©todo seleccionado -->
                    <div class="traversal-explanation" id="traversalExplanation">
                        <h4>üìã Preorden + Inorden</h4>
                        <p>Proporciona los recorridos <strong>Preorden</strong> y <strong>Inorden</strong> para reconstruir el √°rbol √∫nico.</p>
                        <p><strong>Preorden:</strong> Ra√≠z ‚Üí Izquierda ‚Üí Derecha</p>
                        <p><strong>Inorden:</strong> Izquierda ‚Üí Ra√≠z ‚Üí Derecha</p>
                    </div>
                    
                    <!-- Campos para Preorden + Inorden -->
                    <div class="traversal-inputs active" id="preorderInorderInputs">
                        <div class="input-group">
                            <label for="preorderInput">Preorden (Ra√≠z-Izq-Der):</label>
                            <input type="text" id="preorderInput" placeholder="Ej: A,B,D,E,C,F">
                        </div>
                        
                        <div class="input-group">
                            <label for="inorderInput">Inorden (Izq-Ra√≠z-Der):</label>
                            <input type="text" id="inorderInput" placeholder="Ej: D,B,E,A,F,C">
                        </div>
                        
                        <button class="btn" id="reconstructFromPreInBtn">
                            üîÑ RECONSTRUIR DESDE PREORDEN+INORDEN
                        </button>
                    </div>
                    
                    <!-- Campos para Inorden + Postorden -->
                    <div class="traversal-inputs" id="inorderPostorderInputs">
                        <div class="input-group">
                            <label for="inorderInput2">Inorden (Izq-Ra√≠z-Der):</label>
                            <input type="text" id="inorderInput2" placeholder="Ej: D,B,E,A,F,C">
                        </div>
                        
                        <div class="input-group">
                            <label for="postorderInput">Postorden (Izq-Der-Ra√≠z):</label>
                            <input type="text" id="postorderInput" placeholder="Ej: D,E,B,F,C,A">
                        </div>
                        
                        <button class="btn" id="reconstructFromInPostBtn">
                            üîÑ RECONSTRUIR DESDE INORDEN+POSTORDEN
                        </button>
                    </div>
                </div>
                
                <!-- Modo Operaciones -->
                <div class="tab-content" id="operationsTab">
                    <div class="alert alert-warning">
                        <span>‚ÑπÔ∏è</span>
                        <div>Operaciones individuales sobre el √°rbol actual</div>
                    </div>
                    
                    <div class="input-group">
                        <label for="insertNodeInput">Insertar nodo:</label>
                        <input type="text" id="insertNodeInput" placeholder="Valor del nodo">
                        <button class="btn btn-success" id="insertNodeBtn">
                            ‚ûï INSERTAR NODO
                        </button>
                    </div>
                    
                    <div class="input-group">
                        <label for="deleteNodeInput">Eliminar nodo:</label>
                        <input type="text" id="deleteNodeInput" placeholder="Valor del nodo">
                        <button class="btn btn-danger" id="deleteNodeBtn">
                            üóëÔ∏è ELIMINAR NODO
                        </button>
                    </div>
                    
                    <div class="input-group">
                        <label for="searchNodeInput">Buscar nodo:</label>
                        <input type="text" id="searchNodeInput" placeholder="Valor del nodo">
                        <button class="btn btn-warning" id="searchNodeBtn">
                            üîç BUSCAR NODO
                        </button>
                    </div>
                    
                    <div class="input-group">
                        <button class="btn btn-secondary" id="generateRandomTreeBtn">
                            üé≤ GENERAR √ÅRBOL ALEATORIO
                        </button>
                    </div>
                </div>
                
                <!-- Recorridos -->
                <div class="input-group">
                    <h3 class="panel-title">
                        üìä RECORRIDOS
                        <span class="info-icon tooltip">‚ÑπÔ∏è
                            <span class="tooltiptext">Realiza diferentes tipos de recorridos sobre el √°rbol actual y visualiza los resultados</span>
                        </span>
                    </h3>
                    <button class="btn btn-secondary" id="showPreorderBtn">
                        üìã PREORDEN
                    </button>
                    <button class="btn btn-secondary" id="showInorderBtn">
                        üìä INORDEN
                    </button>
                    <button class="btn btn-secondary" id="showPostorderBtn">
                        üìù POSTORDEN
                    </button>
                    <button class="btn btn-secondary" id="animateTraversalBtn">
                        üé¨ ANIMAR RECORRIDO
                    </button>
                </div>
                
                <!-- Gesti√≥n de archivos -->
                <div class="input-group">
                    <h3 class="panel-title">
                        üíæ GESTI√ìN DE ARCHIVOS
                        <span class="info-icon tooltip">‚ÑπÔ∏è
                            <span class="tooltiptext">Guarda y carga √°rboles desde archivos JSON para uso posterior</span>
                        </span>
                    </h3>
                    <button class="btn btn-success" id="exportTreeBtn">
                        üíæ EXPORTAR √ÅRBOL
                    </button>
                    <input type="file" id="importTreeFile" class="file-upload" accept=".json">
                    <label for="importTreeFile" class="file-label">
                        üìÇ IMPORTAR √ÅRBOL
                    </label>
                    <button class="btn btn-danger" id="clearTreeBtn">
                        üóëÔ∏è LIMPIAR TODO
                    </button>
                </div>
                
                <!-- Ejemplos -->
                <div class="input-group">
                    <h3 class="panel-title">
                        üí° EJEMPLOS
                        <span class="info-icon tooltip">‚ÑπÔ∏è
                            <span class="tooltiptext">Carga ejemplos predefinidos para explorar las funcionalidades</span>
                        </span>
                    </h3>
                    <div class="examples">
                        <button class="btn btn-secondary" id="exampleArrayNumbersBtn">
                            üî¢ N√öMEROS
                        </button>
                        <button class="btn btn-secondary" id="exampleArrayLettersBtn">
                            üî§ LETRAS
                        </button>
                        <button class="btn btn-secondary" id="exampleTraversalsBtn">
                            üîÑ RECORRIDOS
                        </button>
                        <button class="btn btn-secondary" id="exampleComplexTreeBtn">
                            üåê √ÅRBOL COMPLEJO
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Panel central: Visualizaci√≥n -->
            <div class="panel visualization-area">
                <canvas id="treeCanvas"></canvas>
                <div class="empty-state" id="emptyState">
                    <h3>üå≥ √ÅRBOL VAC√çO</h3>
                    <p>Usa los controles del panel izquierdo para crear tu primer √°rbol binario</p>
                </div>
            </div>
            
            <!-- Panel derecho: Informaci√≥n y resultados -->
            <div class="panel right-panel">
                <h2 class="panel-title">
                    üìä INFORMACI√ìN
                    <span class="info-icon tooltip">‚ÑπÔ∏è
                        <span class="tooltiptext">M√©tricas y propiedades del √°rbol actualmente visualizado</span>
                    </span>
                </h2>
                
                <div class="tree-info">
                    <div class="info-card">
                        <div class="value" id="nodeCount">0</div>
                        <div class="label">NODOS</div>
                    </div>
                    <div class="info-card">
                        <div class="value" id="treeHeight">0</div>
                        <div class="label">ALTURA</div>
                    </div>
                    <div class="info-card">
                        <div class="value" id="treeLevels">0</div>
                        <div class="label">NIVELES</div>
                    </div>
                    <div class="info-card">
                        <div class="value" id="treeBalanced">NO</div>
                        <div class="label">BALANCEADO</div>
                    </div>
                </div>
                
                <div class="results" id="resultsContainer">
                    <div class="alert alert-success">
                        <span>‚úÖ</span>
                        <div>Listo para crear √°rboles binarios</div>
                    </div>
                </div>
                
                <div class="result-item" id="preorderResult" style="display: none;">
                    <h4>üìã PREORDEN</h4>
                    <p id="preorderText"></p>
                </div>
                
                <div class="result-item" id="inorderResult" style="display: none;">
                    <h4>üìä INORDEN</h4>
                    <p id="inorderText"></p>
                </div>
                
                <div class="result-item" id="postorderResult" style="display: none;">
                    <h4>üìù POSTORDEN</h4>
                    <p id="postorderText"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de ayuda -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal">
            <div class="modal-header">
                <h2>üìö GU√çA DE USO - VISUALIZADOR DE √ÅRBOLES BINARIOS</h2>
                <button class="close-modal" id="closeModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="help-section">
                    <h3>üå≥ ¬øQU√â ES UN √ÅRBOL BINARIO?</h3>
                    <p>Un √°rbol binario es una estructura de datos jer√°rquica donde cada nodo tiene como m√°ximo dos hijos (izquierdo y derecho).</p>
                    <p>En este visualizador, trabajamos principalmente con <strong>√Årboles Binarios de B√∫squeda (BST)</strong>, donde:</p>
                    <ul>
                        <li>Todos los valores en el sub√°rbol izquierdo son menores que el valor del nodo</li>
                        <li>Todos los valores en el sub√°rbol derecho son mayores que el valor del nodo</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>‚öôÔ∏è M√âTODOS DE CREACI√ìN</h3>
                    <p><strong>Desde Array:</strong> Introduce valores separados por comas. El sistema crear√° autom√°ticamente un BST balanceado.</p>
                    <p><strong>Desde Recorridos:</strong> Proporciona dos de los tres recorridos para reconstruir el √°rbol √∫nico:</p>
                    <ul>
                        <li><strong>Preorden:</strong> Ra√≠z ‚Üí Izquierda ‚Üí Derecha</li>
                        <li><strong>Inorden:</strong> Izquierda ‚Üí Ra√≠z ‚Üí Derecha</li>
                        <li><strong>Postorden:</strong> Izquierda ‚Üí Derecha ‚Üí Ra√≠z</li>
                    </ul>
                    <p><strong>Operaciones Individuales:</strong> Inserta, elimina o busca nodos espec√≠ficos en el √°rbol actual.</p>
                </div>

                <div class="help-section">
                    <h3>üìä RECORRIDOS DEL √ÅRBOL</h3>
                    <p>Puedes visualizar los diferentes recorridos del √°rbol actual:</p>
                    <ul>
                        <li><strong>Preorden:</strong> Muestra el orden en que los nodos ser√≠an visitados comenzando por la ra√≠z</li>
                        <li><strong>Inorden:</strong> Muestra los valores en orden ascendente (para BST)</li>
                        <li><strong>Postorden:</strong> Muestra el orden de eliminaci√≥n de nodos (de las hojas hacia la ra√≠z)</li>
                    </ul>
                    <p>La funci√≥n de <strong>animaci√≥n</strong> te permite visualizar paso a paso c√≥mo se realiza cada recorrido.</p>
                </div>

                <div class="help-section">
                    <h3>üíæ GESTI√ìN DE ARCHIVOS</h3>
                    <p><strong>Exportar:</strong> Guarda el √°rbol actual en un archivo JSON que incluye todos los recorridos y metadatos.</p>
                    <p><strong>Importar:</strong> Carga un √°rbol previamente guardado desde un archivo JSON.</p>
                    <p><strong>Limpiar:</strong> Elimina el √°rbol actual para comenzar de nuevo.</p>
                </div>

                <div class="help-section">
                    <h3>üí° CONSEJOS DE USO</h3>
                    <ul>
                        <li>Comienza con los ejemplos predefinidos para familiarizarte con la herramienta</li>
                        <li>Usa la animaci√≥n de recorridos para entender mejor c√≥mo funcionan los algoritmos</li>
                        <li>Experimenta con diferentes tama√±os de √°rbol para ver c√≥mo afecta la visualizaci√≥n</li>
                        <li>Exporta tus √°rboles m√°s interesantes para compartirlos o usarlos m√°s tarde</li>
                    </ul>
                </div>

                <div class="help-section">
                    <h3>üîç INFORMACI√ìN DEL √ÅRBOL</h3>
                    <p>El panel derecho muestra informaci√≥n importante sobre el √°rbol actual:</p>
                    <ul>
                        <li><strong>Nodos:</strong> N√∫mero total de nodos en el √°rbol</li>
                        <li><strong>Altura:</strong> Longitud del camino m√°s largo desde la ra√≠z hasta una hoja</li>
                        <li><strong>Niveles:</strong> N√∫mero de niveles en el √°rbol (igual a la altura)</li>
                        <li><strong>Balanceado:</strong> Indica si el √°rbol est√° balanceado (diferencia de altura entre sub√°rboles ‚â§ 1)</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // CLASE TREE NODE
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = 0;
                this.y = 0;
                this.level = 0;
            }
        }

        // CLASE TREE VISUALIZER
        class TreeVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.root = null;
                this.nodeRadius = 30;
                this.levelHeight = 100;
                this.treeType = "Ninguno";
                this.nodePositions = new Map();
                this.animationNodes = [];
                this.animationIndex = 0;
                this.animationInterval = null;
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                this.drawTree();
            }

            // M√âTODO PARA CREAR BST DESDE ARRAY
            buildBSTFromArray(array, isNumbers = true) {
                if (array.length === 0) return null;
                
                // Ordenar el array para crear un BST balanceado
                let sortedArray;
                if (isNumbers) {
                    sortedArray = [...array].sort((a, b) => a - b);
                } else {
                    sortedArray = [...array].sort();
                }
                
                return this._buildBalancedBST(sortedArray, 0, sortedArray.length - 1);
            }

            _buildBalancedBST(array, start, end) {
                if (start > end) return null;
                
                const mid = Math.floor((start + end) / 2);
                const node = new TreeNode(array[mid]);
                
                node.left = this._buildBalancedBST(array, start, mid - 1);
                node.right = this._buildBalancedBST(array, mid + 1, end);
                
                return node;
            }

            // M√âTODOS PARA RECONSTRUCCI√ìN DESDE RECORRIDOS
            buildFromPreorderInorder(preorder, inorder) {
                if (preorder.length === 0 || inorder.length === 0) return null;
                if (preorder.length !== inorder.length) {
                    throw new Error("Los recorridos deben tener la misma longitud");
                }

                const rootVal = preorder[0];
                const root = new TreeNode(rootVal);
                const rootIndex = inorder.indexOf(rootVal);

                if (rootIndex === -1) {
                    throw new Error(`Elemento ${rootVal} no encontrado en inorden`);
                }

                const leftInorder = inorder.slice(0, rootIndex);
                const rightInorder = inorder.slice(rootIndex + 1);
                const leftPreorder = preorder.slice(1, 1 + leftInorder.length);
                const rightPreorder = preorder.slice(1 + leftInorder.length);

                root.left = this.buildFromPreorderInorder(leftPreorder, leftInorder);
                root.right = this.buildFromPreorderInorder(rightPreorder, rightInorder);

                return root;
            }

            buildFromInorderPostorder(inorder, postorder) {
                if (inorder.length === 0 || postorder.length === 0) return null;
                if (inorder.length !== postorder.length) {
                    throw new Error("Los recorridos deben tener la misma longitud");
                }

                const rootVal = postorder[postorder.length - 1];
                const root = new TreeNode(rootVal);
                const rootIndex = inorder.indexOf(rootVal);

                if (rootIndex === -1) {
                    throw new Error(`Elemento ${rootVal} no encontrado en inorden`);
                }

                const leftInorder = inorder.slice(0, rootIndex);
                const rightInorder = inorder.slice(rootIndex + 1);
                const leftPostorder = postorder.slice(0, leftInorder.length);
                const rightPostorder = postorder.slice(leftInorder.length, postorder.length - 1);

                root.left = this.buildFromInorderPostorder(leftInorder, leftPostorder);
                root.right = this.buildFromInorderPostorder(rightInorder, rightPostorder);

                return root;
            }

            // NUEVOS M√âTODOS PARA OPERACIONES DE NODOS
            insert(value) {
                const newNode = new TreeNode(value);
                
                if (this.root === null) {
                    this.root = newNode;
                } else {
                    this.insertNode(this.root, newNode);
                }
                
                this.drawTree();
            }

            insertNode(node, newNode) {
                if (newNode.value < node.value) {
                    if (node.left === null) {
                        node.left = newNode;
                    } else {
                        this.insertNode(node.left, newNode);
                    }
                } else {
                    if (node.right === null) {
                        node.right = newNode;
                    } else {
                        this.insertNode(node.right, newNode);
                    }
                }
            }

            delete(value) {
                this.root = this.deleteNode(this.root, value);
                this.drawTree();
            }

            deleteNode(node, value) {
                if (node === null) return null;
                
                if (value < node.value) {
                    node.left = this.deleteNode(node.left, value);
                    return node;
                } else if (value > node.value) {
                    node.right = this.deleteNode(node.right, value);
                    return node;
                } else {
                    // Caso 1: Nodo sin hijos
                    if (node.left === null && node.right === null) {
                        return null;
                    }
                    
                    // Caso 2: Nodo con un solo hijo
                    if (node.left === null) {
                        return node.right;
                    } else if (node.right === null) {
                        return node.left;
                    }
                    
                    // Caso 3: Nodo con dos hijos
                    const minNode = this.findMinNode(node.right);
                    node.value = minNode.value;
                    node.right = this.deleteNode(node.right, minNode.value);
                    return node;
                }
            }

            findMinNode(node) {
                if (node.left === null) return node;
                return this.findMinNode(node.left);
            }

            search(value) {
                return this.searchNode(this.root, value);
            }

            searchNode(node, value) {
                if (node === null) return null;
                
                if (value < node.value) {
                    return this.searchNode(node.left, value);
                } else if (value > node.value) {
                    return this.searchNode(node.right, value);
                } else {
                    return node;
                }
            }

            highlightNode(value) {
                this.clearHighlights();
                const node = this.search(value);
                if (node) {
                    this.nodePositions.set(node, { ...this.nodePositions.get(node), highlighted: true });
                    this.drawTree();
                    return true;
                }
                return false;
            }

            clearHighlights() {
                this.nodePositions.forEach((position, node) => {
                    this.nodePositions.set(node, { ...position, highlighted: false });
                });
            }

            generateRandomTree(count = 10, min = 1, max = 100) {
                const numbers = [];
                for (let i = 0; i < count; i++) {
                    numbers.push(Math.floor(Math.random() * (max - min + 1)) + min);
                }
                
                // Eliminar duplicados
                const uniqueNumbers = [...new Set(numbers)];
                
                this.root = this.buildBSTFromArray(uniqueNumbers, true);
                this.treeType = "√Årbol Aleatorio";
                this.drawTree();
                
                return uniqueNumbers;
            }

            // ANIMACI√ìN DE RECORRIDOS
            animateTraversal(traversalType) {
                this.stopAnimation();
                
                let nodes = [];
                switch (traversalType) {
                    case 'preorder':
                        nodes = this.preorderTraversal(this.root);
                        break;
                    case 'inorder':
                        nodes = this.inorderTraversal(this.root);
                        break;
                    case 'postorder':
                        nodes = this.postorderTraversal(this.root);
                        break;
                    default:
                        return;
                }
                
                this.animationNodes = nodes;
                this.animationIndex = 0;
                
                this.animationInterval = setInterval(() => {
                    if (this.animationIndex < this.animationNodes.length) {
                        this.highlightNode(this.animationNodes[this.animationIndex]);
                        this.animationIndex++;
                    } else {
                        this.stopAnimation();
                    }
                }, 800);
            }

            stopAnimation() {
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                }
                this.clearHighlights();
                this.drawTree();
            }

            calculateTreeInfo(node) {
                if (!node) return { height: 0, nodeCount: 0, balanced: true };
                
                const leftInfo = this.calculateTreeInfo(node.left);
                const rightInfo = this.calculateTreeInfo(node.right);
                
                const height = Math.max(leftInfo.height, rightInfo.height) + 1;
                const nodeCount = leftInfo.nodeCount + rightInfo.nodeCount + 1;
                const balanced = leftInfo.balanced && rightInfo.balanced && 
                                Math.abs(leftInfo.height - rightInfo.height) <= 1;
                
                return { height, nodeCount, balanced };
            }

            calculatePositions(node, level, minPos, maxPos) {
                if (!node) return;
                
                node.level = level;
                node.y = level * this.levelHeight + 80;
                node.x = (minPos + maxPos) / 2;

                // Guardar posici√≥n para uso posterior
                this.nodePositions.set(node, { x: node.x, y: node.y, highlighted: false });

                if (node.left) {
                    this.calculatePositions(node.left, level + 1, minPos, node.x - 60);
                }
                if (node.right) {
                    this.calculatePositions(node.right, level + 1, node.x + 60, maxPos);
                }
            }

            drawTree() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (!this.root) {
                    document.getElementById('emptyState').style.display = 'block';
                    return;
                }
                
                document.getElementById('emptyState').style.display = 'none';

                this.nodePositions.clear();
                this.calculatePositions(this.root, 0, 60, this.canvas.width - 60);
                this.drawConnections(this.root);
                this.drawNode(this.root);
                
                // Actualizar informaci√≥n del √°rbol
                this.updateTreeInfo();
            }

            drawConnections(node) {
                if (!node) return;

                const nodePos = this.nodePositions.get(node);

                this.ctx.strokeStyle = nodePos.highlighted ? '#00ff88' : '#00f7ff';
                this.ctx.lineWidth = nodePos.highlighted ? 4 : 3;
                this.ctx.shadowBlur = 15;
                this.ctx.shadowColor = nodePos.highlighted ? '#00ff88' : '#00f7ff';

                if (node.left) {
                    const leftPos = this.nodePositions.get(node.left);
                    this.ctx.beginPath();
                    this.ctx.moveTo(nodePos.x, nodePos.y);
                    this.ctx.lineTo(leftPos.x, leftPos.y);
                    this.ctx.stroke();
                    this.drawConnections(node.left);
                }

                if (node.right) {
                    const rightPos = this.nodePositions.get(node.right);
                    this.ctx.beginPath();
                    this.ctx.moveTo(nodePos.x, nodePos.y);
                    this.ctx.lineTo(rightPos.x, rightPos.y);
                    this.ctx.stroke();
                    this.drawConnections(node.right);
                }

                this.ctx.shadowBlur = 0;
            }

            drawNode(node) {
                if (!node) return;

                const nodePos = this.nodePositions.get(node);

                // Gradiente para el nodo
                const gradient = this.ctx.createRadialGradient(
                    nodePos.x, nodePos.y, 0, nodePos.x, nodePos.y, this.nodeRadius
                );
                
                if (nodePos.highlighted) {
                    gradient.addColorStop(0, '#00ff88');
                    gradient.addColorStop(1, '#00c466');
                } else {
                    gradient.addColorStop(0, '#00f7ff');
                    gradient.addColorStop(1, '#00aacc');
                }

                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(nodePos.x, nodePos.y, this.nodeRadius, 0, 2 * Math.PI);
                this.ctx.fill();

                // Borde del nodo
                this.ctx.strokeStyle = nodePos.highlighted ? '#00ff88' : '#00c4cc';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                // Sombra del nodo
                this.ctx.shadowBlur = 20;
                this.ctx.shadowColor = nodePos.highlighted ? '#00ff88' : '#00f7ff';

                // Texto del nodo
                this.ctx.fillStyle = '#0a0a0f';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(node.value, nodePos.x, nodePos.y);

                this.ctx.shadowBlur = 0;

                // Recursi√≥n para hijos
                this.drawNode(node.left);
                this.drawNode(node.right);
            }

            updateTreeInfo() {
                if (!this.root) {
                    document.getElementById('nodeCount').textContent = '0';
                    document.getElementById('treeHeight').textContent = '0';
                    document.getElementById('treeLevels').textContent = '0';
                    document.getElementById('treeBalanced').textContent = 'NO';
                    return;
                }

                const info = this.calculateTreeInfo(this.root);
                document.getElementById('nodeCount').textContent = info.nodeCount;
                document.getElementById('treeHeight').textContent = info.height;
                document.getElementById('treeLevels').textContent = info.height;
                document.getElementById('treeBalanced').textContent = info.balanced ? 'S√ç' : 'NO';
            }

            // M√©todos de recorrido
            preorderTraversal(node, result = []) {
                if (!node) return result;
                result.push(node.value);
                this.preorderTraversal(node.left, result);
                this.preorderTraversal(node.right, result);
                return result;
            }

            inorderTraversal(node, result = []) {
                if (!node) return result;
                this.inorderTraversal(node.left, result);
                result.push(node.value);
                this.inorderTraversal(node.right, result);
                return result;
            }

            postorderTraversal(node, result = []) {
                if (!node) return result;
                this.postorderTraversal(node.left, result);
                this.postorderTraversal(node.right, result);
                result.push(node.value);
                return result;
            }

            // Exportar √°rbol a JSON
            exportToJSON() {
                if (!this.root) {
                    throw new Error("No hay √°rbol para exportar");
                }

                const treeData = {
                    preorder: this.preorderTraversal(this.root),
                    inorder: this.inorderTraversal(this.root),
                    postorder: this.postorderTraversal(this.root),
                    nodeCount: this.calculateTreeInfo(this.root).nodeCount,
                    treeType: this.treeType,
                    exportDate: new Date().toISOString()
                };

                return JSON.stringify(treeData, null, 2);
            }

            // Importar √°rbol desde JSON
            importFromJSON(jsonData) {
                try {
                    const data = JSON.parse(jsonData);
                    
                    if (data.preorder && data.inorder) {
                        this.root = this.buildFromPreorderInorder(data.preorder, data.inorder);
                        this.treeType = data.treeType || "Desde Recorridos";
                        this.drawTree();
                        return true;
                    } else if (data.inorder && data.postorder) {
                        this.root = this.buildFromInorderPostorder(data.inorder, data.postorder);
                        this.treeType = data.treeType || "Desde Recorridos";
                        this.drawTree();
                        return true;
                    } else {
                        throw new Error("Formato JSON inv√°lido: faltan recorridos necesarios");
                    }
                } catch (error) {
                    throw new Error(`Error al importar: ${error.message}`);
                }
            }

            clear() {
                this.root = null;
                this.treeType = "Ninguno";
                this.nodePositions.clear();
                this.stopAnimation();
                this.drawTree();
            }
        }

        // INICIALIZACI√ìN MEJORADA
        document.addEventListener('DOMContentLoaded', function() {
            const treeVisualizer = new TreeVisualizer('treeCanvas');
            
            // Tabs functionality
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // Remove active class from all tabs and contents
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab') + 'Tab';
                    document.getElementById(tabId).classList.add('active');
                });
            });

            // Modal functionality
            const helpModal = document.getElementById('helpModal');
            const helpBtn = document.getElementById('helpBtn');
            const closeModal = document.getElementById('closeModal');

            helpBtn.addEventListener('click', () => {
                helpModal.classList.add('active');
            });

            closeModal.addEventListener('click', () => {
                helpModal.classList.remove('active');
            });

            // Close modal when clicking outside
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    helpModal.classList.remove('active');
                }
            });

            // MEJORA: Selector de m√©todo de reconstrucci√≥n
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all method buttons
                    document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    const method = this.getAttribute('data-method');
                    
                    // Hide all traversal inputs
                    document.querySelectorAll('.traversal-inputs').forEach(input => {
                        input.classList.remove('active');
                    });
                    
                    // Show selected traversal inputs
                    if (method === 'preorder-inorder') {
                        document.getElementById('preorderInorderInputs').classList.add('active');
                        document.getElementById('traversalExplanation').innerHTML = `
                            <h4>üìã Preorden + Inorden</h4>
                            <p>Proporciona los recorridos <strong>Preorden</strong> y <strong>Inorden</strong> para reconstruir el √°rbol √∫nico.</p>
                            <p><strong>Preorden:</strong> Ra√≠z ‚Üí Izquierda ‚Üí Derecha</p>
                            <p><strong>Inorden:</strong> Izquierda ‚Üí Ra√≠z ‚Üí Derecha</p>
                        `;
                    } else if (method === 'inorder-postorder') {
                        document.getElementById('inorderPostorderInputs').classList.add('active');
                        document.getElementById('traversalExplanation').innerHTML = `
                            <h4>üìä Inorden + Postorden</h4>
                            <p>Proporciona los recorridos <strong>Inorden</strong> y <strong>Postorden</strong> para reconstruir el √°rbol √∫nico.</p>
                            <p><strong>Inorden:</strong> Izquierda ‚Üí Ra√≠z ‚Üí Derecha</p>
                            <p><strong>Postorden:</strong> Izquierda ‚Üí Derecha ‚Üí Ra√≠z</p>
                        `;
                    }
                });
            });

            // Construir desde Array
            document.getElementById('buildFromArrayBtn').addEventListener('click', () => {
                const arrayInput = document.getElementById('arrayInput').value;
                const arrayType = document.getElementById('arrayType').value;
                
                try {
                    let array;
                    if (arrayType === 'numbers') {
                        array = arrayInput.split(',').map(item => {
                            const num = parseFloat(item.trim());
                            if (isNaN(num)) throw new Error(`"${item}" no es un n√∫mero v√°lido`);
                            return num;
                        });
                    } else {
                        array = arrayInput.split(',').map(item => item.trim().toUpperCase());
                        if (array.some(item => item.length !== 1 || !item.match(/[A-Z]/))) {
                            throw new Error("Solo se permiten letras individuales de A-Z");
                        }
                    }

                    if (array.length === 0) {
                        throw new Error("El array no puede estar vac√≠o");
                    }

                    // Eliminar duplicados
                    const uniqueArray = [...new Set(array)];
                    if (uniqueArray.length !== array.length) {
                        showWarning(`Se eliminaron ${array.length - uniqueArray.length} elementos duplicados`);
                    }

                    treeVisualizer.root = treeVisualizer.buildBSTFromArray(uniqueArray, arrayType === 'numbers');
                    treeVisualizer.treeType = `BST desde Array (${arrayType === 'numbers' ? 'N√∫meros' : 'Letras'})`;
                    treeVisualizer.drawTree();
                    showSuccess(`√Årbol BST creado desde array con ${uniqueArray.length} elementos √∫nicos`);
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Reconstruir desde Preorden + Inorden
            document.getElementById('reconstructFromPreInBtn').addEventListener('click', () => {
                const preorder = document.getElementById('preorderInput').value.split(',').map(s => s.trim()).filter(s => s);
                const inorder = document.getElementById('inorderInput').value.split(',').map(s => s.trim()).filter(s => s);
                
                try {
                    validateTraversalInputs(preorder, inorder, []);
                    treeVisualizer.root = treeVisualizer.buildFromPreorderInorder(preorder, inorder);
                    treeVisualizer.treeType = "Desde Preorden+Inorden";
                    treeVisualizer.drawTree();
                    showSuccess('√Årbol reconstruido exitosamente desde Preorden + Inorden');
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Reconstruir desde Inorden + Postorden
            document.getElementById('reconstructFromInPostBtn').addEventListener('click', () => {
                const inorder = document.getElementById('inorderInput2').value.split(',').map(s => s.trim()).filter(s => s);
                const postorder = document.getElementById('postorderInput').value.split(',').map(s => s.trim()).filter(s => s);
                
                try {
                    validateTraversalInputs([], inorder, postorder);
                    treeVisualizer.root = treeVisualizer.buildFromInorderPostorder(inorder, postorder);
                    treeVisualizer.treeType = "Desde Inorden+Postorden";
                    treeVisualizer.drawTree();
                    showSuccess('√Årbol reconstruido exitosamente desde Inorden + Postorden');
                    updateTraversalResults(treeVisualizer);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // NUEVAS FUNCIONALIDADES: Operaciones de nodos
            document.getElementById('insertNodeBtn').addEventListener('click', () => {
                const value = document.getElementById('insertNodeInput').value.trim();
                
                if (!value) {
                    showError('Por favor ingresa un valor para insertar');
                    return;
                }
                
                try {
                    let nodeValue;
                    if (treeVisualizer.root && typeof treeVisualizer.root.value === 'number') {
                        nodeValue = parseFloat(value);
                        if (isNaN(nodeValue)) throw new Error('El valor debe ser un n√∫mero');
                    } else {
                        nodeValue = value.toUpperCase();
                        if (nodeValue.length !== 1 || !nodeValue.match(/[A-Z]/)) {
                            throw new Error('El valor debe ser una letra de A-Z');
                        }
                    }
                    
                    // Verificar si ya existe
                    if (treeVisualizer.search(nodeValue)) {
                        throw new Error(`El nodo ${nodeValue} ya existe en el √°rbol`);
                    }
                    
                    treeVisualizer.insert(nodeValue);
                    treeVisualizer.treeType = "√Årbol con inserci√≥n individual";
                    showSuccess(`Nodo ${nodeValue} insertado exitosamente`);
                    updateTraversalResults(treeVisualizer);
                    document.getElementById('insertNodeInput').value = '';
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            document.getElementById('deleteNodeBtn').addEventListener('click', () => {
                const value = document.getElementById('deleteNodeInput').value.trim();
                
                if (!value) {
                    showError('Por favor ingresa un valor para eliminar');
                    return;
                }
                
                try {
                    let nodeValue;
                    if (treeVisualizer.root && typeof treeVisualizer.root.value === 'number') {
                        nodeValue = parseFloat(value);
                        if (isNaN(nodeValue)) throw new Error('El valor debe ser un n√∫mero');
                    } else {
                        nodeValue = value.toUpperCase();
                        if (nodeValue.length !== 1 || !nodeValue.match(/[A-Z]/)) {
                            throw new Error('El valor debe ser una letra de A-Z');
                        }
                    }
                    
                    if (!treeVisualizer.search(nodeValue)) {
                        throw new Error(`El nodo ${nodeValue} no existe en el √°rbol`);
                    }
                    
                    treeVisualizer.delete(nodeValue);
                    treeVisualizer.treeType = "√Årbol con eliminaci√≥n";
                    showSuccess(`Nodo ${nodeValue} eliminado exitosamente`);
                    updateTraversalResults(treeVisualizer);
                    document.getElementById('deleteNodeInput').value = '';
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            document.getElementById('searchNodeBtn').addEventListener('click', () => {
                const value = document.getElementById('searchNodeInput').value.trim();
                
                if (!value) {
                    showError('Por favor ingresa un valor para buscar');
                    return;
                }
                
                try {
                    let nodeValue;
                    if (treeVisualizer.root && typeof treeVisualizer.root.value === 'number') {
                        nodeValue = parseFloat(value);
                        if (isNaN(nodeValue)) throw new Error('El valor debe ser un n√∫mero');
                    } else {
                        nodeValue = value.toUpperCase();
                        if (nodeValue.length !== 1 || !nodeValue.match(/[A-Z]/)) {
                            throw new Error('El valor debe ser una letra de A-Z');
                        }
                    }
                    
                    const found = treeVisualizer.highlightNode(nodeValue);
                    if (found) {
                        showSuccess(`Nodo ${nodeValue} encontrado en el √°rbol`);
                    } else {
                        showError(`Nodo ${nodeValue} no encontrado en el √°rbol`);
                    }
                    document.getElementById('searchNodeInput').value = '';
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            document.getElementById('generateRandomTreeBtn').addEventListener('click', () => {
                const numbers = treeVisualizer.generateRandomTree(10, 1, 100);
                showSuccess(`√Årbol aleatorio generado con valores: ${numbers.join(', ')}`);
                updateTraversalResults(treeVisualizer);
            });

            // Botones de recorridos
            document.getElementById('showPreorderBtn').addEventListener('click', () => {
                if (!treeVisualizer.root) {
                    showError('No hay √°rbol para recorrer');
                    return;
                }
                const result = treeVisualizer.preorderTraversal(treeVisualizer.root);
                document.getElementById('preorderText').textContent = result.join(' ‚Üí ');
                document.getElementById('preorderResult').style.display = 'block';
            });

            document.getElementById('showInorderBtn').addEventListener('click', () => {
                if (!treeVisualizer.root) {
                    showError('No hay √°rbol para recorrer');
                    return;
                }
                const result = treeVisualizer.inorderTraversal(treeVisualizer.root);
                document.getElementById('inorderText').textContent = result.join(' ‚Üí ');
                document.getElementById('inorderResult').style.display = 'block';
            });

            document.getElementById('showPostorderBtn').addEventListener('click', () => {
                if (!treeVisualizer.root) {
                    showError('No hay √°rbol para recorrer');
                    return;
                }
                const result = treeVisualizer.postorderTraversal(treeVisualizer.root);
                document.getElementById('postorderText').textContent = result.join(' ‚Üí ');
                document.getElementById('postorderResult').style.display = 'block';
            });

            // Animaci√≥n de recorridos
            document.getElementById('animateTraversalBtn').addEventListener('click', () => {
                if (!treeVisualizer.root) {
                    showError('No hay √°rbol para animar');
                    return;
                }
                
                // Mostrar di√°logo para seleccionar tipo de recorrido
                const traversalType = prompt('Selecciona el tipo de recorrido:\n1. Preorden\n2. Inorden\n3. Postorden', '1');
                
                let type;
                switch (traversalType) {
                    case '1':
                        type = 'preorder';
                        break;
                    case '2':
                        type = 'inorder';
                        break;
                    case '3':
                        type = 'postorder';
                        break;
                    default:
                        showError('Tipo de recorrido no v√°lido');
                        return;
                }
                
                treeVisualizer.animateTraversal(type);
                showSuccess(`Animando recorrido ${type}`);
            });

            // Exportar √°rbol
            document.getElementById('exportTreeBtn').addEventListener('click', () => {
                try {
                    const jsonData = treeVisualizer.exportToJSON();
                    const fileName = prompt("Ingresa el nombre del archivo (sin extensi√≥n):", `arbol_binario_${new Date().getTime()}`);
                    
                    if (!fileName) return;
                    
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${fileName}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showSuccess(`√Årbol exportado exitosamente como ${fileName}.json`);
                } catch (error) {
                    showError(`${error.message}`);
                }
            });

            // Importar √°rbol
            document.getElementById('importTreeFile').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        treeVisualizer.importFromJSON(e.target.result);
                        showSuccess('√Årbol importado exitosamente');
                        updateTraversalResults(treeVisualizer);
                    } catch (error) {
                        showError(`${error.message}`);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Reset input
            });

            // Limpiar √°rbol
            document.getElementById('clearTreeBtn').addEventListener('click', () => {
                treeVisualizer.clear();
                showSuccess('√Årbol limpiado');
                hideTraversalResults();
                hideResults();
            });

            // Ejemplos
            document.getElementById('exampleArrayNumbersBtn').addEventListener('click', () => {
                document.getElementById('arrayInput').value = '5,3,7,1,9,2,8,4,6';
                document.getElementById('arrayType').value = 'numbers';
                showSuccess('Ejemplo de n√∫meros cargado. Haz clic en "CREAR √ÅRBOL BINARIO"');
            });

            document.getElementById('exampleArrayLettersBtn').addEventListener('click', () => {
                document.getElementById('arrayInput').value = 'D,B,F,A,C,E,G';
                document.getElementById('arrayType').value = 'letters';
                showSuccess('Ejemplo de letras cargado. Haz clic en "CREAR √ÅRBOL BINARIO"');
            });

            document.getElementById('exampleTraversalsBtn').addEventListener('click', () => {
                // Cargar ejemplo seg√∫n el m√©todo seleccionado
                const activeMethod = document.querySelector('.method-btn.active').getAttribute('data-method');
                
                if (activeMethod === 'preorder-inorder') {
                    document.getElementById('preorderInput').value = 'A,B,D,E,C,F';
                    document.getElementById('inorderInput').value = 'D,B,E,A,F,C';
                    showSuccess('Ejemplo de Preorden+Inorden cargado. Haz clic en "RECONSTRUIR √ÅRBOL"');
                } else {
                    document.getElementById('inorderInput2').value = 'D,B,E,A,F,C';
                    document.getElementById('postorderInput').value = 'D,E,B,F,C,A';
                    showSuccess('Ejemplo de Inorden+Postorden cargado. Haz clic en "RECONSTRUIR √ÅRBOL"');
                }
            });

            document.getElementById('exampleComplexTreeBtn').addEventListener('click', () => {
                document.getElementById('arrayInput').value = '50,30,70,20,40,60,80,10,25,35,45,55,65,75,85,5,15,23,27,33,37,43,47,53,57,63,67,73,77,83,87';
                document.getElementById('arrayType').value = 'numbers';
                showSuccess('Ejemplo de √°rbol complejo cargado. Haz clic en "CREAR √ÅRBOL BINARIO"');
            });

            // Funciones auxiliares
            function validateTraversalInputs(preorder, inorder, postorder) {
                if (inorder.length === 0) {
                    throw new Error("El recorrido INORDEN es obligatorio");
                }

                const hasPreorder = preorder.length > 0;
                const hasPostorder = postorder.length > 0;

                if (!hasPreorder && !hasPostorder) {
                    throw new Error("Debe proporcionar Preorden O Postorden junto con Inorden");
                }

                if (hasPreorder && hasPostorder) {
                    throw new Error("Solo debe proporcionar Preorden O Postorden, no ambos");
                }

                if (hasPreorder && preorder.length !== inorder.length) {
                    throw new Error("Preorden e Inorden deben tener la misma longitud");
                }

                if (hasPostorder && postorder.length !== inorder.length) {
                    throw new Error("Postorden e Inorden deben tener la misma longitud");
                }

                // Validar elementos √∫nicos y mismos conjuntos
                const inorderSet = new Set(inorder);
                const comparisonSet = hasPreorder ? new Set(preorder) : new Set(postorder);

                if (inorderSet.size !== inorder.length) {
                    throw new Error("El recorrido Inorden no puede tener elementos duplicados");
                }

                if (comparisonSet.size !== (hasPreorder ? preorder.length : postorder.length)) {
                    throw new Error("El otro recorrido no puede tener elementos duplicados");
                }

                if (inorderSet.size !== comparisonSet.size || ![...inorderSet].every(item => comparisonSet.has(item))) {
                    throw new Error("Los recorridos deben contener los mismos elementos");
                }
            }

            function showError(message) {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-error fade-in">
                        <span>‚ùå</span>
                        <div>${message}</div>
                    </div>
                `;
            }

            function showSuccess(message) {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-success fade-in">
                        <span>‚úÖ</span>
                        <div>${message}</div>
                    </div>
                `;
            }

            function showWarning(message) {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-warning fade-in">
                        <span>‚ö†Ô∏è</span>
                        <div>${message}</div>
                    </div>
                `;
            }

            function hideResults() {
                const resultsContainer = document.getElementById('resultsContainer');
                resultsContainer.innerHTML = `
                    <div class="alert alert-success">
                        <span>‚úÖ</span>
                        <div>Listo para crear √°rboles binarios</div>
                    </div>
                `;
            }

            function updateTraversalResults(tree) {
                const preorder = tree.preorderTraversal(tree.root);
                const inorder = tree.inorderTraversal(tree.root);
                const postorder = tree.postorderTraversal(tree.root);
                
                document.getElementById('preorderText').textContent = preorder.join(' ‚Üí ');
                document.getElementById('inorderText').textContent = inorder.join(' ‚Üí ');
                document.getElementById('postorderText').textContent = postorder.join(' ‚Üí ');
                
                document.getElementById('preorderResult').style.display = 'block';
                document.getElementById('inorderResult').style.display = 'block';
                document.getElementById('postorderResult').style.display = 'block';
            }

            function hideTraversalResults() {
                document.getElementById('preorderResult').style.display = 'none';
                document.getElementById('inorderResult').style.display = 'none';
                document.getElementById('postorderResult').style.display = 'none';
            }
        });
    </script>
</body>
</html>